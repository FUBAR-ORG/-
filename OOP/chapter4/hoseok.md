# 4장 유연한 인터페이스 만들기
- 객체지향 애플리케이션을 클래스의 총합으로 이해해 버리려는 유혹에 빠지기 쉬움
- 클래스 레벨에서 취급해야 하는 디자인 이슈도 있지만, 그 이상의 것들이 있음
- 애플리케이션은 클래스로 구성되어 있지만, 메시지를 통해 정의됨
- 따라서, 메시지에 중점을 두어야함

## 4.1 인터페이스 이해하기
---
- 모든 객체가 다른 모든 객체에게 아무 메시지나 전송하면
- 재사용 하기 힘듦, 얼기설기 얽혀 있기 때문
- 독립적으로 존재하는 객체는 없으며, 하나를 재사용 하기 위해 전체를 사용해야하고 하나를 수정하려면 전체를 수정해야함
- 메시지들은 정확하게 드러나는 패턴
- 객체들은 명확하게 잘 정의된 방식으로 소통
- 조립이 가능함
- 각 객체는 최소한으로 드러내며 다른 객체에 대해 가능한 한 조금 알고 있음
- 때문에 재사용이 편함
- 밖으로 노출된 메서드가 클래스의 퍼블릭 인터페이스를 구성
- 하나의 클래스로부터 독립되어 있고 여러 클래스 사이를 돌아다니는 또 다른 종류의 인터페이스도 있음
- 인터페이스는 메시지의 묶음으로 표현
- 젠체의 한 부분인 각 클래스는 이런 인터페이스가요구하는 메서드들을 구현
- 인터페이스가 가상의 클래스를 정의하고 있는 것과 같음

## 4.2 인터페이스 정의하기
---
- 식당을 예로
- 퍼블릭 인터페이스 : 손님이 사용 가능한 인터페이스, 즉 메뉴판
- 프라이빗 인터페이스 : 부엌안에서 벌어지는 일들

> 클래스는 부엌과 같음. 하나의 책임을 제대로 수행하기 위해 존재하며 숨낳은 메서드를 구현하고 있음. 클래스 내부에서 어떤 메서드는 퍼블릭 메서드, 어떤 메서드는 프라이빗 메서드임

### 4.2.1 퍼블릭 인터페이스
---
- 바깥 세상을 향한 클래스의 얼굴
- 클래스의 핵심 책임 (primary responsibility)을 드러냄
- 다른 객체에 의해 호출될 수 있음
- 쉽게 변경되지 않음
- 다른 객체가 안정적으로 의존할 수 있음
- 테스트를 통해 꼼꼼하게 문서화되어 있음

### 4.2.2 프라이빗 인터페이스
---
- 그 외의 메서드
- 세부적인 구현을 담당
- 다른 객체에 의해 호출되지 않음
- 필요에 따라 언제든 변경 가능
- 다른 객체가 의존하기에는 위험
- 테스트에서 다루지 않을 수 있음

### 4.2.3 책임, 의존성 그리고 인터페이스
---
- 2장에서 얻은 교훈 : 퍼블릭 메서드에 적용가능
  - 클래스에 목표가 하나뿐일 때 클래스의 활동은 목표를 이루기 위한 것
  - 퍼블릭 인터페이스는 클래스의 구체적인 책임을 표현한 문장과 조응

- 3장에서 얻은 교훈 : 프라이빗 메서드에 적용가능
  - 클래스를 퍼블릭한 부분과 프라이빗한 부분으로 구분하면 자신보다 덜 변화하는 것에 의존해야 한다는 생각을 클래스 내부에도 적용가능

## 4.3퍼블릭 인터페이스 찾아내기
---

### 4.3.1 예시 애플리케이션: 자전거 여행 회사
---
- 알아야 할 요구사항 ( 예시 )
  - 여행객은, 여행길을 선택하기 위해서, 정해진 날짜에, 자신에게 맞는 난이도의, 자전거를 빌릴 수 있는, 여행길 목록을 보고싶어 함

### 4.3.2 의도를 구성하기
---
- 위 예시를 보고 떠올린 클래스 : Customer(여행객), Route(여행길), Bike(자전거), Mechanic(정비공), Trip(여행)
- 클래스를 바로 떠올릴 수 있었던 이유 : 정보(data)와 행동(behavior) 둘다 가지고 있는 명사들을 표하기 때문 ( 도메인 객체 )
- 도메인 객체는 조심스럽게 다루어야 함

### 4.3.4 '어떻게(How)'해야 하는지 말해주지 말고, '어떤 것(What)'을 달라고 요구하기
---
- 그림 4.5 ( 참고 : 79 or 80 page )
  - Trip은 clean_bicycle, pump_tires, lube_chain, check_brakes 메서드를 가지고 있는 객체를 필요로함
- 위 디자인에서 Trip이 Mechanic이 하는 세세한 작업을 다 알고 있음
- 즉, Mechanic의 어떻게와 관련된 메서드들을 Trip에서 알고 있음
- 때문에 Mechanic이 변경이 되면 Trip도 변경이 필요함
---
- 그림 4.6 ( 참고 : 80 page )
  - Trip은 prepare_bicycle 메서드를 가지고 있는 객체가 필요함
- 위 디자인에서 Trip은 여러 책임을 Mechanic에게 넘겨줌
- 어떻게와 관련된 책임이 모두 Mechanic에게 넘어갔음
- 때문에 Mechanic이 변경이 되도 Trip은 문제가 없음

> 위 예제에서 Trip과 Mechanic에 대한 논의가 어떻게에서 어떤 것으로 변경됨에 따라 의존성을 낮추는 효과를 볼 수 있다는 것

### 4.3.5 주어진 맥락에서 독립적일 수 있게 하기
---
- 의존성 주입을 활용하여 서로 독립적으로 만듦
- Trip이 원하는 것 : 어떤 것이 준비되어야 한다
- Mechanic이 처리해야 하는 영역 : 자전거가 준비되어야 한다
- 여행을 어떻게 준비하는가 : 자전거를 준비해야 한다
- 그림 4.7 ( 참고 : 83 page )
  - Trip의 퍼블릭 인터페이스는 bicycles를 포함
  - Mechanic의 퍼블릭 인터페이스는 prepare_trip을 포함, 아마도 prepare_bicycle도 포함
  - Trip은 prepare_trip 메서드에 반응할 수 있는 개체가 필요
  - Mechanic은 prepare_trip의 인자로 bicycles에 반응할 수 있는 객체가 필요
- 위처럼 수정한다면 서로 독립적이며, 수정 및 테스트, 재사용 등이 쉬워짐

### 4.3.6 다른 객체를 믿기
---
- 그림 4.5
  - 절차적
  - Trip은 Mechanic이 어떻게 Bicycle을 준비해야 하는지 알려줌
  - 마치 Trip이 메인 프로그램이고 Mechanic은 호출할 수 있는 함수의 덩어리와 같이 보임
  - 자전거를 준비하려면 Trip을 사용하거나 중복코드를 만들 수 밖에 없음

- 그림 4.6
  - 조금 더 객체지향적
  - Trip은 Mechanic에게 Bicycle을 준비하라고 요구
  - 자전거를 준비하기 위해 Trip이 꼭 어야하는 것은 아니며, 덜 결합되어 있어 손쉽게 재사용이 가능
  - Trip과 Mechanic에 각자의 책임을 올바르게 위치 시켜 놓음
  - 하지만 Trip은 언제나 prepare_bicycle 메서드에 반응하는 객체를 필요로 함

- 그림 4.7
  - 훨씬 더 객체지향적
  - Trip은 prepare_trip 메시지를 보낼 객체만 있으면 됨

## 4.4 자신의 인터페이스를 드러내는 코드 작성하기
---
- 완벽한 인터페이스를 구현하는 것은 어려운 일임
- 인터페이스를 만들 때 염두에 두어야하는 기본적인 원칙을 다룸

### 4.4.1 명시적인 인터페이스 만들기
---
- 퍼블릭 인터페이스는 아래와 같음

  - 일반적인 의미, 엄밀하고 명시적으로 규정되어 있어야 함
  - 어떻게보다는 어떤 것에 대해 말해야 함
  - 예측할 수 있는 한도에서나마 바뀌지 않을 이름을 지어야 함
  - 추가적인 인자를 해시로 받아라
  - 퍼블릭 인터페이스 뿐만 아니라 프라이빗 메서드 또한 의도를 가지고 명시적으로 만드는 것이 좋음

- protected, private 키워드를 사용한다는 의미는 아래와 같음
  - private keyword
    - 키워드는 가장 불안정하고 눈에 띄지 않는 종류의 메서드르 나타냄
    - 수신자가 생략되어 있을 경우에만 호출가능
    - 반대로 표현하자면, 수신자가 명시적으로 정해져 있는 경우 호출할 수 없음
  - protected keyword
    - 불안정한 메서드를 나타냄
    - 노출 정도에서 private keyword와 차이가 있음
    - 수신자가 self or 같은 클래스의 인스턴스 or self의 자식 클래스의 인스턴스일 경우에만 명시적인 수신자를 지정할 수 있음
  - public
    - 위에 정리해 둔 내용으로 대체

- 위 3가지 키워드를 사용한다는 의미
  - 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿음
  - 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야 함

### 4.4.2 다른 이의 퍼블릭 인페이스를 존중하자
---
- 다른 클래스와 협업할 때는 그 클래스의 public 인터페이스만 사용하도록 노력해야 함
- 디자인이 다른 클래스의 private 메서드를 사용하도록 유도한다면 디자인에 대해 다시 생각하고 다른 대안을 찾아야 함

 > private 메서드를 사용하지 않을 수 있는 방법을 찾기 위해 노력이 필요함

- 코드가 프라이빗 인터페이스에 의존하고 있으면 변화에 영향을 받을 위험성이 높음
- 외부 프레임워크에 프라이빗 메서드에 대한 의존성은 최대한 피해야 함

### 4.4.4 최소한의 맥락 속에 위치시키기
---
- public 인터페이스를 구성할 때는 다른 객체들과의 연계되어 있는 맥락을 최소화할 수 있는 방향을 염두할 것
- "어떤 것" 과 "어떻게"사이의 구분을 기억할 것
- 반대로 public 인터페이스가 없거나 public 인터페이스가 잘못 정의된 클래스가 시키는 대로 따르지 말 것
- 어떤 방식이든 사용하기 편한 방식을 사용하되, public 인터페이스는 꼭 만들것
- public 인터페이스를 통해 클래스를 둘러싼 맥락이 줄어들고 다시 재사용이 용이해지며 테스트가 편리해질 것임

## 4.5 데메테르의 원칙
---
- 데메테르의 원칙은 객체들의 결합도를 낮추면서 코딩할 수 있도록 해주는 규칙
- 데메테르 원칙을 어겨도 아무런 문제가 되지 않을 수도 있짐나, public 인터페이스를 제대로 정의하지 못했다는 반증이 되기도 함

### 4.5.1 데메테르 원칙 정의
---
- 메서드가 메시지를 전송하지 말 것을 요구
- 메시지를 전달받은 객체가 바로 이어 다른 타입의 객체에서 메시지를 전달하는 것을 금지
- '바로 옆에 있는 이웃하고만 소통하라', '점을 하나만 사용하라'로 표현할 수도 있다. 

### 4.5.2 위반의 결과
- Trip의 depart 메서드가 아래의 코드를 포함하고 있다고 가정

```cpp
costomer.bicycle.wheel.tire; // #1
costomer.bicyle.wheel.rotate(); // #2
hash.keys.sort.join(', '); // #3
```
- #1, #2 이 두 코드는 먼 곳에 있는 어트리뷰트(tire)를 가져오고 멀리 있는 행동(rotate())을 호출하는 차이만 있을 뿐 두 코드의 연쇄는 거의 같은 것
- 어트리뷰트를 반환하는 메시지 연쇄에 데메테르의 원칙을 강요하는 것은 의견이 분분함
- 이를 구분하기 위해서는 데메테르의 원칙을 따르는 비용과 미래의 수정비용을 잘 판단해야 함
  - 예를 들어, 연관된 객체들의 목록을 출력하려 한다면 중간에 낀 객체를 명시적으로 표시하고 꼭 필요할 때에만 목록을 수정하는 것이 가장 좋은 전략임
  - 안정적인 어트리뷰트를 다루고 있을 때는 데메테르의 원칙을 위반해도 문제가 안됨
  - 만약, depart가 customer.bicycle.wheel.tire의 결과를 변경하려는 의도를 가지고 메시지를 전송하면, 단순히 어트리뷰트를 가져오는 것이 아님
  - 이는 중간에 여러 객체를 끼고 있는 메시지 연쇄를 통해 멀리 있는 행동에 접근하고 있는 것
- #3은 String의 Enumerable을 반환하며 중간에 낀 객체들은 모두 같은 타입을 반환하고있다. 따라서 데메테르 원칙을 위반한 것은 아님
  - hash.keys == Enumerable 반환
  - hash.keys.sort == Enumerable 반환
  - hash.keys.sort.join == string 반환 ( string의 Enumerable 반환 )

- 이 원칙은 자체로 완결적인 것이 아니며 어기는 것이 말이 되는 경우도 있지만, 어떤 경우는 이 원칙을 따르는 것이 어플리케이션의 유연성을 높이고 유지보수를 쉽게 해줄 것

### 4.5.3 데메테르의 원칙을 위반하지 않기
---
- 데메테르의 원칙을 피하기 위한 방법중 하나는 위임을 사용하는 것
- 메시지 연쇄에 포함되어 있는 지식을 캡슐화 하거나 감춘 레퍼 메서드를 통해 위임이 가능
- 위임은 데메테르의 원칙을 위반했다는 표시를 지워버리기 때문에 데메테르의 원칙을 따르기 위한 손쉬운 방법으로 생각될 수 있음
- 이는 코드의 강한 결합을 감추는 것은 코드의 결합도를 낮추는 것이 전혀 아님

### 4.5.4 데메테르의 원칙에 귀 귀울이기
---
- 데메테르의 원칙은 위임을 많이 사용하자를 말하는 것이 아님
- 메시지 연쇄는 우리가 이미 잘 알고 있는 객체로부터 영향을 받을 때 만들어짐
- 이미 알고 있는 객체의 퍼블릭 인터페이스에 익숙하기 때문에 긴 메시지 연쇄를 통해 멀리 있는 행동에 접근함

- "저 멀리에 내가 원하는 행동이 있는데 나는 이 행동을 어떻게 가져올지 알고 있다"는 말은 이질적인 객체를 사이에 두고 먼 곳에 있는 행동에 접근하는 것임
- 이는 자신이 원하는 것이 "어떤 것 ( rotate() )" 인지 알고 있을 뿐 아니라 여러 객레들을 "어떻게" 타고가야 원하는 행동을 얻을 수 있는지도 알고 있는 것

- 위 내용은 강하게 결합되어 있다는 것을 말하며, 이는 재사용 및 유지보수에 많은 비용을 초래할 것이라는 것을 의미함

```cpp
customer.ride();
```
- ride 메서드는 세부적인 구현을 Trip으로부터 감추고 맥락과 의존성을 모두 줄여주는 형식으로 만들 수 있음
