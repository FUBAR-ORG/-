# 유연한 인터페이스 만들기

- 객체 지향 애플리케이션을 클래스의 총합으로 이해해 버리려는 유혹에 빠지면 안됨.
- 애플리케이션은 클래스로 구성되어 있지만 메시지를 통해 정의.
- 객체가 무엇을 아는지(객체의 책임)와 누구를 알고 있는지(객체의 의존성) 뿐만 아니라, 어떻게 소통하는지 알아야 함.

> 객체 사이의 소통은 인터페이스를 통해 이루어짐.

## 인터페이스 이해하기

- 메세지들이 눈에 띄는 패턴을 보여주지 않고, 모든 객체가 다른 모든 객체에게 아무 메세지나 전송하는 경우, 해당 애플리케이션의 객체는 재사용하기 어려움.
- 메세지들이 정확하게 드러나는 패턴을 보여주고, 명확하게 잘 정의된 방식으로 소통하는 경우, 조립 가능하게(`plugable`) 구성되어 자기 자신을 최소한으로 드러내며, 다른 객체에 대해 가능한 한 조금만 알고 있음.

> 첫 번째 경우의 디자인 이슈는 각 클래스가 무엇을 하는지에 아는 것이 아니라, 무엇을 드러내는지에 있음.

> 밖으로 노출된 메서드를 클래스의 퍼블릭 인터페이스(`public interface`)라 함.

### 인터페이스

1. 클래스 안에 있는 인터페이스.

   - 클레스는 메서드를 구현하고, 그중 일부는 클래스 외부 객체가 사용하기 위함.
   - 이 메서드들이 클래스의 퍼블릭 인터페이스 구현.

2. 하나의 클래스로부터 독립되어 있고 여러 클래스 사이를 돌아다니는 종류의 인터페이스.

   - 메세지의 묶음으로 표현.
   - 메세지들 자체가 인터페이스를 정의.
   - 전체의 한 부분인 각 클래스는 이런 인터페이스가 요구하는 메서드들을 구현.
     > 이는 마치 인터페이스가 가상의(`virtual`) 클래스를 정의하고 있는 것.  
     > 인터페이스가 요구하는 메서드를 구현하고 있다면, 어떤 클래스든 인터페이스 같은 것처럼 동작.

---

## 인터페이스 정의하기

- 퍼블릭 메서드: 어떤 메서드는 우리 클래스의 메뉴판 같은 역할.
- 프라이빗 메서드: 자잘한 내부 구현에 관여.

### 퍼블릭 인터페이스

> 클래스의 퍼블릭 인터페이스를 구성하는 메서드는 바깥 세상을 향한 클래스의 얼굴.

- 클래스의 핵심 책임(`primary responsibility`)을 드러냄.
- 다른 객체에 의해 호출 가능.
- 쉽게 변경 불가.
- 다른 객체가 안정적으로 의존 가능.
- 테스트를 통해 꼼꼼하게 문서화.

### 프라이빗 인터페이스

> 퍼블릭 메서드 외의 메서드는 프라이빗 인터페이스의 한 부분.

- 세부적인 구현 담당.
- 다른 객체에 의해 호출되지 않음.
- 필요에 따라 언제든 변경.
- 다른 객체가 의존하기 위험.
- 테스트에서 다루지 않음.

### 책임, 의존성 그리고 인터페이스

- 책임

  > 단일 책임 원칙을 따르는 클래스의 퍼블릭 인터페이스는 클래스의 책임을 명시해주는 계약서.

- 의존성

  > 클래스를 퍼블릭한 부분과 프라이빗한 부분으로 구분하면 자신보다 덜 변화하는 것에 의존해야 한다는 생각은 클래스 내부에도 적용.

- 인터페이스

  - 퍼블릭한 부분은 안정적인 부분.
  - 프라이빗한 부분은 변경될 수 있는 부분.
  - 이 클래스 사용자에게 어떤 메서드에 의존하는 것이 보다 안정적인지 알려주는 것.

  > 하나의 클래스가 다른 클래스의 퍼블릭 메서드를 사용하고 있다면 이 메서드가 안정적이기를 기대.  
  > 프라이빗 메서드를 사용하기로 마음 먹었다면 본질적으로 불안정한 것에 의존.

---

## 퍼블릭 인터페이스 찾아내기

### 예시 애플리케이션: 자전거 여행 회사

1. 패스트핏 주식회사는 로드 바이크 여행과 마운틴 바이크 여행을 다룸.
2. 패스트핏이 추천하는 여행길은 방문 횟수가 제한되어 있고, 정해진 수의 가이드 겸 정비공이 필요.
3. 각 여행길은 체력 조건에 따라 난이도 별로 분류.
4. 여행객은 자전거를 빌릴 수도 있고 가지고 와도 됨.

#### 유스케이스

- 여행객은,
- 여행길을 선택하기 위해서,
- 정해진 날짜에,
- 자신에게 맞는 난이도의,
- 자전거를 빌릴 수 있는,
- 여행길 목록을 보고싶어 함.

### 의도를 구성하기

- `Customer`, `Trip`, `Route`, `Bike`, `Mechanic` 클래스를 쉽게 떠올릴 수 있음.
- 이 클래스들은 정보(`data`)와 행동(`behavior`) 둘 다를 가지고 있는 명사들을 표현하기 때문.
  > 이것들을 도메인 객체(`domain objects`)라 함.
- 도메인 객체는 매우 명시적.
- 하지만 도메인 객체는 핵심을 차지하지 않으며, 집착할 경우 행동들을 이 객체 속에 넣어버리는 함정에 빠짐.
  > 도메인 객체가 아닌 도메인 객체가 주고 받는 메세지에 주목.
- 이 메세지들은 잘 드러나지 않는 중요한 새로운 객체를 찾도록 도와줌.

### 시퀀스 다이어그램 사용하기

> 시퀀스 다이어그램: 객체와 메세지를 탐구해 볼 수 있는 완벽하고 값싼 방법. 통함 모델링 언어(`UML`, `Unified Modeling Language`)에 정의되어 있는 많은 다이어그램 중 하나.

- 객체들의 배치와 메세지 전송 전략에 대해 검토해 볼 수 있는 간단한 방법 제공.
- 유스케이스에 포함된 명사들은 시퀀스 다이어그램에서 객체로 표현.
- 유스케이스에 행동들은 메세지로 변경.
- 시퀀스 다이어그램을 통해 인터페이스를 드러내고 실험하여 디자인에 대한 논의의 방향을 바꿈.
  > 메세지를 중심으로 디자인을 이야기할 수 있게 됨.

> 메세지 기반의 디자인 관점은 클래스 기반의 관점보다 훨씬 유연한 애플리케이션을 만들 수 있게 해줌.

### 어떻게(`How`) 해야 하는지 말해주지 말고, 어떤 것(`What`)을 달라고 요구하기

- 송신자(`sender`)가 원하는 것을 요구하는 메세지와 수신자(`receiver`)가 어떻게 행동해야 하는지 알려주는 메세지를 구분하는 것은 매우 중요.

- 유스케이스 1

  - `Trip` 퍼블릭 인터페이스는 `bicycles` 메서드를 포함.
  - `Mechanic`의 퍼블릭 인터페이스는 `clean_bicycle`, `pump_tires`, `lube_chain` 그리고 `check_brakes` 메서드를 포함.
  - `Trip`은 `clean_bicycle`, `pump_tires`, `lube_chain` 그리고 `check_brakes` 메서드를 가지고 있는 객체를 필요.

- 이 과정에서 `Trip`은 `Mechanic`이 하는 세세한 작업을 다 알고 있음.
- 이럴 경우 만약 `Mechanic`이 준비 과정에 수리도구 세트를 장착했는지 확인하는 메서드를 추가한다면, `Trip`은 이 메서드를 호출하도록 수정되어야 함.

- 유스케이스 2

  - `Trip` 퍼블릭 인터페이스는 `bicycles` 메서드를 포함.
  - `Mechanic`의 퍼블릭 인터페이스는 `prepare_bicycle` 메서드를 포함.
  - `Trip`에게는 `prepare_bicycle` 메서드를 가지고 있는 객체가 필요.

- 여기서 `Trip`은 `Mechanic`에게 여러 책임을 넘겨줌.
- `Trip`은 자전거가 준비되어 있기를 바라고 `Mechanic`이 이 작업을 제대로 수행하리라 믿고 있음.
- 어떻게와 관련된 책임이 모두 `Mechanic`에게 넘어갔기 때문에 나중에 `Mechanic`을 보완하더라도 `Trip`은 언제나 원하는 결과를 얻음.

> 어떻게에서 어떤 것으로 논의가 바뀌었을 때 부수적인 효과 중 하나는 퍼블릭 인터페이스의 양이 줄었다는 점.

### 주어진 맥락에서 독립적일 수 있게 하기

- `Trip`이 다른 객체에 대해 알고 있다는 사실이 `Trip`이 속한 맥락(`context`)을 구성.

  > `Trip`은 하나의 책임을 지고 있지만, 특정한 맥락을 필요로 함.

- `Trip`을 사용하려면 맥락(예제에서는 자전거)이 설정되어 있어야 함.
- 객체가 필요로 하는 맥락은 객체의 재사용성에 영향을 미침.
- 가능한 최고의 상황은 객체가 자신의 맥락으로부터 완전히 독립되어 있는 것.
- 의존성을 주입하는 방법을 통해 맥락에 독립적이면서 협업 가능하게 구성할 수 있음.
- `Trip`이 원하는 어떤 것이 준비되어야 함. 하지만 자전거를 준비해야 하는 것은 `Mechanic`이 처리해야 함.

- 유스케이스 3

  - `Trip` 퍼블릭 인터페이스는 `bicycles` 메서드를 포함.
  - `Mechanic`의 퍼블릭 인터페이스는 `prepare_trip` 메서드를 포함하고, 아마도 `prepare_bicycle`도 포함하고 있을 것.
  - `Trip`은 `prepare_trip` 메서드에 반응할 수 있는 객체가 필요.
  - `Mechanic`은 `prepare_trip`의 인자로 `bicycles`에 반응할 수 있는 객체가 필요.

- 정비공이 어떻게 여행을 준비하는지에 대한 지식은 `Mechanic` 속에 고립되고, `Trip`의 맥락은 줄어듬.

### 다른 객체를 믿기

- 유스케이스 1은 다분히 절차적(`procedural`)으로, `Trip`이 원하는 것을 알고 있고, `Mechanic`이 어떻게 해야하는지도 알고 있음.
- 유스케이스 2는 조금은 객체지향적으로, `Trip`이 원하는 것을 알고 있고, `Mechanic`이 원하는 것도 알고 있음.

  - `Trip`의 맥락이 줄어들고 `Mechanic`의 퍼블릭 인터페이스도 작아짐.
  - `Mechanic`의 퍼블릭 인터페이스는 어떤 객체가 사용을 하든 도움이 됨.

  > 덜 결합되어 있고, 손쉽게 재사용 가능.

- 유스케이스 3는 훨씬 더 객체지향적으로, `Trip`이 원하는 것을 알고 있고, `Mechanic`이 주어진 역할을 제대로 하리라 믿고 있음.

  - 이런 접근을 보다 확장시키면, `Trip`은 `Mechanic` 같은 객체들을 배열에 담아 놓고 각각에게 `prepare_trip` 메세지를 전송할 수 있음.
  - 이런 패턴을 따르면, 새로운 여행 준비 담당 객체를 추가해도 전혀 코드를 수정할 필요가 없음.

  > `Trip`을 변경하지 않고도 확장할 수 있게 됨.

> 이 맹목적인 믿음이 객체지향 디자인의 핵심.

### 새로운 객체를 찾아내기 위해 메세지를 사용하기

- 아직 정의되지 않은 새로운 객체가 필요하다는 인식은 여러 경로를 통해 얻을 수 있음.
- 시퀀스 다이어그램을 통해서 깨닫게 되면 틀렸을 때 지불해야 하는 비용이 매우 낮고 다른 선택을 하는데 걸림돌이 거의 없다는 이점.
- 시퀀스 다이어그램은 실험적으로 사용해보고 버릴 수 있지만, 디자인의 시작점, 그 의도를 만들어낼 수 있음.
- 유스케이스에는 추가적으로 메세지를 전송할 객체가 필요.
- `TripFinder` 클래스가 어울리는 여행을 찾아주고, 여행을 여행객과 어울리게 만드는 것이 무엇인지 모두 알고 있음.
- 이 클래스는 안정적인 퍼블릭 인터페이스를 제공.
- `suitable_trips` 메서드를 `TripFinder`로 옮겼기 때문에 다른 객체들도 이 행동에 접근 가능.

### 메세지 기반 애플리케이션 만들기

- 시퀀스 다이어그램으로 우리가 메세지에 집중할 수 있도록 도와주고 첫 번째로 통과시켜야 하는 테스트의 합리적인 의도를 형성할 수 있도록 해줌.
- 우리의 관심을 객체에서 메세지로 옮기면서 퍼블릭 인터페이스 기반으로 애플리케이션을 디자인하는 데 집중할 수 있게 됨.

---

## 자신의 인터페이스를 드러내는 코드 작성하기

- 애플리케이션의 특징을 드러내고 그 미래를 결정하는 것은 **인터페이스**.

### 명시적인 인터페이스 만들기

> 다른 사람이 우리가 작성한 메서드를 실행할 때 어떤 메서드에 의존해도 괜찮은지 알려줄 의무.

- 퍼블릭 인터페이스의 메서드

  - 일반적인 의미, 엄밀하고 명시적으로 규정되어 있어야 함.
  - 어떻게보다는 어떤 것에 대해 말해야 함.
  - 예측할 수 있는 한도에서나마 바뀌지 않을 이름을 지어야 함.
  - 추가적인 인자(`options parameter`)를 해시로 받음.

- 프라이빗 인터페이스도 의도를 가지고 명시적으로 만드는 것이 좋음.
- 테스트는 그 자체로 문서의 역할을 하기 때문에 이런 노력을 뒷받침.

> 프라이빗 메서드는 테스트를 작성하지 않거나, 꼭 만들어야 한다면 퍼블릭 메서드 테스트와는 분리해 놓는 편이 좋음.

- 접근 지정자(`public`, `protected`, `private`)의 역할

  1. 메서드가 안정적인지 아닌지 알려 줌. => 안정성을 알려주는 일.
  2. 다른 객체들에게 해당 메서드가 얼마나 노출되는지 결정. => 어떻게 사용할지 관리하는 일.

  - `private`

    - 가장 불안정하고 눈에 띄지 않는 종류의 메서드.
    - 수신자가 생략되어 있을 경우에만 호출. => 명시적으로 정해져 있을 때는 호출 불가.

  - `protected`
    - 불안정한 메서드를 나타냄.
    - 수신자가 `self`이거나 `self`의 자식 클래스의 인스턴스일 경우에 한해 명시적인 수신자 지정.

- 이 키워드들은 접근을 막지 않고, 단지 좀 더 번거롭게 만듬.

  - 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿는다.
  - 내가 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야 한다고 생각한다.

- 키워드들을 사용하기보다는 주석을 달거나 메서드 이름에 나름의 관행을 적용해서 퍼블릭 인터페이스와 프라이빗 인터페이스를 구분함.

> 어떤 방식으로 처리하든 메서드의 안정성에 대한 정보를 전달해 주었다면 우리는 미래에 대한 의무를 다한 것.

### 다른 이의 퍼블릭 인터페이스를 존중하자

- 다른 클래스와 협업할 때는 그 클래스의 퍼블릭 인터페이스만 사용하도록 노력해야 함.
- 우리를 도와주기 위한 이 구분에 주의를 기울일 필요가 잇음.
- 프라이빗 메서드를 사용하지 않을 수 있는 방법을 찾기 위해 열심히 노력해야 함.

> 외부 프레임워크의 프라이빗 메서드에 대한 의존은 기술적인 빚.

### 프라이빗 인터페이스에 의존할 때는 특별히 주의를 기울어야 한다

> 이 경우가 어쩔 수 없이 있기 마련이지만, 의존성을 고립시켜 위험을 최소화해야 함.

### 최소한의 맥락 속에서 위치시키기

- 퍼블릭 인터페이스를 구성할 때는 다른 객체들과 연계되어 있는 맥락을 최소화 할 수 있는 방향을 염두.
- 어떤 것과 어떻게 사이의 구분을 기억.
- 송신자가 원하는 것을 클래스에 요청할 때 우리가 작성한 클래스의 구현과 작동방식에 대해 전혀 몰라도 되는 퍼블릭 인터페이스 작성.

> 퍼블릭 인터페이스는 꼭 만들어야 함. 이를 통해 클래스를 둘러싼 맥락이 줄어들고 다시 사용하기 쉬워지며 테스트하기도 편해짐.

---

## 데메테르의 원칙

- 데메테르의 원칙(`LoD`)은 객체들의 결합도를 낮추면서 코딩할 수 있도록 해주는 규칙.
- 낮은 결합(`loosely coupled`)을 갖도록 하는 것은 중요한 덕목이지만 또한 디자인의 여러 측면 중 하나.
- 상반되는 디자인 이슈와 잘 조율하는 능력도 필요.
- 데메테르의 원칙을 어겨도 아무런 문제가 되지 않을 때도 있음.
- 하지만 어떤 경우에는 퍼블릭 인터페이스를 제대로 정의하지 못했다는 것을 의미.

### 데메테르 원칙 정의

> 이 원칙은 메서드가 메세지를 전송하지 말 것을 요구.

- 메세지를 전달받은 객체가 바로 이어 다른 타입의 객체에게 메세지를 전달하는 것을 금지.
  - 바로 옆에 있는 이웃하고만 소통하라.
  - 점을 하나만 사용하라.

```js
customer.bicycle.wheel.tire;
customer.bicycle.wheel.rotate;
hash.keys.sort.join(", ");
```

- 각 줄의 메세지 연쇄는 점(마침표)를 여러 개 포함. => 이를 흔히 고장난 기차(`train wrecks`)에 비유.
- 데메테르의 원칙을 위반하고 있다는 사실을 보여줌.

### 위반의 결과

위의 메세지 연쇄는 투명성, 적절성, 사용가능성, 모범성을 뜻하는 `TRUE`에 비추어 보았을 때도 부적절.

- `tire`나 `rotate`를 수정하면 `depart`가 오작동할 수 있음. `Trip`과 `wheel`은 멀리 떨어져 있고 서로 연관되어 있어 보이지 않기 때문에 오작동을 예상하기 어려우므로 이 코드는 투명(`transparent`)하지 않음.
- 만약 `wheel`이 `tire`나 `rotate`를 변경한다면 `depart`도 변경되어야 함. 불필요한 수정으로 이 코드는 적합(`reasonable`)하지 않음.
- `wheel`과 `tire`를 가지고 있는 `bicycle`이 있지만 이 `bicycle`을 가지고 있는 `customer`가 없다면 `Trip`을 사용할 수 없음. `Trip`을 사용하려면 이런 맥락을 고려해야 하기 때문에 사용(`usable`)하기 쉽지 않음.
- 이런 패턴의 메세지는 비슷한 문제를 가진 코드를 재생산하게 만들어 전혀 모범적(`exemplary`)이지 않음.

<br>

- 특별한 상황에서는 연쇄를 타고 멀리 있는 어트리뷰트에 접근하는 것이 효율적일 수 있음.
- 데메테르의 원칙을 따르는 비용과 미래의 수정 비용을 저울질할 필요.
  - `depart`가 `customer.bicycle.wheel.tire`의 결과를 변경하려는 의도를 가지고 메세지를 전송한다면, 이는 단순히 어트리뷰트를 가지고 오는게 아닌 `Wheel`에 속해야할 행동을 구현하고 있는 것.
- 중간에 여러 객체를 끼고 있는 메세지 연쇄를 통해 멀리 있는 행동에 접근하는 것은 대가가 큼.
- 점이 많다고 데메테르의 원칙을 위반하는 것은 아님.

  - `hash.keys`는 `Enumerable`을 반환.
  - `hash.keys.sort` 역시 `Enumerable`을 반환.
  - `hash.keys.sort.join`은 `String`을 반환.

  > 이 코드에서 점을 제거하려 한다면 유지보수 비용이 늘어남.

> 데메테르의 원칙은 궁극적인 목적을 달성하는 것을 돕기 위해 존재.

### 데메테르의 원칙을 위반하지 않기

- 고장난 기차 형태의 코드를 피하기 위한 방법 중 하나는 위임(`delegation`)을 사용하는 방법.
- 객체지향 프로그래밍에서 메세지를 위임한다는 뜻은 메세지를 다른 객체에게 넘긴다는(`pass`) 뜻.
- 메세지 연쇄에 포함되어 있는 지식을 캡슐화 하거나 감추는 래퍼 메서드를 통함.

> 위임을 통해 코드의 강한 결합을 감추는 것은 코드의 결합도를 낮추는 것이 아님.

### 데메테르의 원칙에 귀 기울이기

- 데메테르의 원칙은 위임을 많이 사용하자가 아님.
- 이질적인 객체 를 사이에 두고 먼 곳에 있는 행동에 접근하는 것은 "저 멀리에 내가 원하는 행동이 있는데 나는 이 행동을 어떻게 가져올지 알고 있다." 즉, 자신이 원하는 것이 어떤 것(`rotate`)인지 알고있을 분 아니라 여러 객체들을 어떻게 타고 가야 원하는 행동을 얻을 수 있는지도 알고 있다는 뜻.
- `depart` 메서드는 여러 객체들을 어떻게 타고 가야 `wheel`을 만날 수 있고, `wheel`에게 `rotate`하라는 메세지를 전달할 수 있는지 알고 있음.

> 결국 `depart` 메서드는 객체들의 전반적인 구조와 강하게 결합.

> `depart` 메서드가 이 객체들의 연쇄를 알고 있기 때문에, 이 객체들의 매우 구체적인 구현에 얽혀 있기 때문에 다른 맥락에서는 전혀 사용할 수 없음.

- `depart` 메서드가 `customer`로부터 어떤 것을 원하는지 판단하면서 코드를 디자인 했다면?

  ```js
  customer.ride;
  ```

  - `ride` 메서드는 세부적인 구현을 `Trip`으로부터 감추고 맥락과 의존성을 모두 줄여줌.

- 데메테르의 원칙을 위반해서 만들어진 고장난 기차 모양은 퍼블릭 인터페이스가 없는 객체가 있다고 말해줌.
- 도메인 객체의 족쇄를 벗어버리지 못하면 기다란 메세지 연쇄를 작성하게 됨.

> 유연한 퍼블릭 인터페이스를 구성할 기회를 잃음.

---

## 요약

- 객체지향 애플리케이션은 객체들이 서로 주고 받는 **메세지**를 통해 정의.
- 이 메세지들은 **퍼블릭 인터페이스**를 타고 흐름.
- 잘 정의된 퍼블릭 인터페이스(안정적인 메서드)는 해당 클래스의 책임을 제대로 드러내줌.
- 메세지에 집중하면 미처 파악하지 못한 객체를 찾을 수 있음.
- 메세지가 어떻게 행동해야하는 지를 알려주기보다, 수신자를 믿고 전송자가 원하는 바를 말해준다면, 자연스럽게 퍼블릭 인터페이스를 발전시키게 됨.

> 이는 보다 유연한 인터페이스, 세련되고 기대치 않았던 방식으로도 재사용할 수 있는 인터페이스를 만들 수 있음.
