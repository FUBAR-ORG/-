# 유연한 인터페이스 만들기

어플리케이션은 클래스로 구성되어 있지만 메시지를 통해 정의된다. 객체가 무엇을 아는지(책임) 누구를 알고 있는지(의존성)뿐만 아니라 객체가 서로 어떻게 소통하는지 알아야한다.

객체 사이의 소통은 인터페이스를 통해 이루어진다.

<br>

## 인터페이스 이해하기

객체는 자기 자신을 최소한으로 드러내며 다른 객체에 대해 가능한 조금 알고 있어야한다. 메시지는 객체간에 어떤 메시지를 주고 받을지에 대한 합의와 규칙이 있어야한다.

인터페이스는 여러 의미를 가지지만 4장에서의 인터페이스는 클래스 안에 있는 인터페이스를 지칭하는 의미이다. 클래스는 메서드를 구현하고 메서드 중 일부는 클래스 외부의 객체가 사용하기 위한 것이다. 이러한 메서드들이 클래스의 퍼블릭 인터페이스를 구성한다.

하나의 클래스로부터 독립되어 있고 여러 클래스를 돌아다니는 인터페이스도 있는데 이러한 인터페이스는 메시지의 묶음으로 표현된다. 따라서 메시지 자체가 인터페이스를 정의한다. 이 인터페이스는 5장에서 다룬다.

<br>

## 인터페이스 정의하기

클래스는 하나의 책임을 제대로 수행하기 위해 존재하며 많은 메서드를 구현하고 있다. 클래스의 핵심 내용을 전반적으로 표현하는 메서드부터 내부에서만 사용하기 위해 만들어진 메서드들까지 메서드의 범위는 다양하다.

부엌을 예로 들면 메뉴판과 같이 손님들이 사용할 수 있는 것이 퍼블릭 인터페이스이며 부엌안에서의 직원들끼리의 메시지는 손님들이 볼 수 없는 프라이빗 인터페이스이다. 이렇듯 퍼블릭과 프라이빗을 구분하면 일을 효율적으로 처리할 수 있다.

### 퍼블릭 인터페이스

퍼블릭 인터페이스를 구성하는 메서드는 다음과 같은 메서드이다.

- 클래스의 핵심 책임을 드러낸다.
- 다른 객체에 의해 호출될 수 있다.
- 쉽게 변경되지 않는다.
- 다른 객체가 안정적으로 의존할 수 있다.
- 테스트를 통해 꼼꼼하게 문서화되어 있다.

### 프라이빗 인터페이스

퍼블릭 인터페이스를 구성하는 메서드는 다음과 같은 메서드이다.

- 세부적인 구현을 담당한다.
- 다른 객체에 의해 호출되지 않는다.
- 필요에 따라 언제든지 변경할 수 있다.
- 다른 객체가 의존하기에는 위험하다.
- 테스트에서 다루지 않을 수도 있다.

### 책임, 의존성 그리고 인터페이스

퍼블릭 인터페이스는 클래스의 책임을 명시해주는 계약서이다. 클래스를 퍼블릭한 부분과 프라이빗한 부분으로 구분하면 자기 자신보다 덜 변하는 클래스에 의존해야 한다는 원칙을 클래스 내부에 적용할 수 있다.

클래스의 퍼블릭한 부분은 안정적인 부분이며 프라이빗한 부분은 변경될 수 있는 부분이다. 퍼블릭과 프라이빗의 구분을 통해 사용자에게 어떤 메서드에 의존하는 것이 알려줄 수 있다.

<br>

## 퍼블릭 인터페이스 찾아내기

디자인의 목표는 당장의 요구사항을 처리하기에 충분한 코드를 작성하며 나중에 수정할 여지를 최대한 확보하는 것이다. 좋은 퍼블릭 인터페이스는 예상치 못한 변화에 대한 비용을 줄여주지만 좋지 않은 인터페이스는 비용을 증대시킨다.

### 의도를 구성하기

클래스들은 어플리케이션속에서 정보와 행동 둘 다를 가지고 있는 명사 즉, 도메인 객체를 표현한다.

우리는 도메인 객체가 아닌 도메인 객체들이 주고 받는 메시지에 주목해야한다. 이 메시지들은 꼭 필요하지만 잘 드러나지 않는 객체를 찾도록 도와주는 가이드이다.

우리의 유스케이스(요구사항)을 만족시켜줄 수 있는 객체들 그리고 메시지들의 의도를 구상할 필요가 있다. 다음은 코드를 작성하지않고 생각을 발전시켜 줄 수 있는 방법들이다.

### 시퀀스 다이어그램 사용하기

시퀀스 다이어그램의 특징 및 장점은 다음과 같다.

- 시퀀스 다이어그램은 통합 모델링 언어(UML)에 정의되어 있는 다이어그램이다.
- 객체들의 배치와 메시지 전송 전략에 대해 검토해볼 수 있는 방법을 제공한다.
- 객체들이 주고 받는 메시지를 명시적으로 드러낸다.

시퀀스 다이어그램을 그리면 '이 클래스의 책임이 맞는가?' 혹은 '이 객체가 이 메시지에 반응할 책이 있는가?' 등에 대해 생각해볼 수 있다.

메시지 기반의 디자인을 위해 '이 클래스는 무엇을 해야하는가'가 아닌 '메시지를 전송 해야하는데 누구에게 전송해야하는가'에 대해 질문해야한다.

**메시지 기반의 디자인 관점은 클래스 기반의 관점보다 훨씬 유연한 어플리케이션을 만들 수 있게 해준다. 객체를 가지고 있기 때문에 메시지를 보내는 것이 아니라 메시지를 전송하기 대문에 객체를 갖게 된것이다.**

### How에 대한 설명이 아닌, What을 달라고 요구하기

송신자가 원하는 것을 요구하는 메시지, 수신자가 어떻게 행동해야 하는지 알려주는 메시지를 구분하는 것은 매우 중요하다.

어떻게에 대한 책임을 어떤 것으로 바꾸어야한다. 책임이 어떻게에서 어떤 것으로 바뀌면 퍼블릭 인터페이스 양을 줄일 수 있다. 퍼블릭 인터페이스의 양이 줄어들면 다른 객체가 의존할 수 있는 사실이 적어진다.

### 주어진 맥락에서 독립적일 수 있게 하기

객체가 필요로하는 맥락은 객체의 재사용성에 영향일 미친다. 단순한 맥락 속의 객체는 사용하기 쉽고 테스트하기 쉽다. 가능한 객체가 자신의 맥락으로부터 완전히 독립되어 있게 해야한다. 쉽게 말해 필요로한 것을 객체 속에 독립적으로 위치하게 디자인해야한다.

### 다른 객체를 믿기

객체들을 잘 정의된 방식으로 소통하게하고 덜 결합되게 디자인하면 객체의 책임을 올바른 자리에 위치시킬 수 있다.

객체가 주어진 역할을 제대로 하고 있다고 믿는 것이 객체지향 디자인의 핵심이다.

### 새로운 객체를 찾아내기 위해 메시지를 사용하기

아직 정의되지 않은 새로운 객체가 필요하다는 인식은 여러 경로를 통해 얻을 수 있다. 새로운 객체가 필요하다는 것은 메시지를 전송할 객체가 필요하다라는 말과 같다.

### 메시지 기반 어플리케이션 만들기

시퀀스 다이어그램을 임시적으로 사용하면 강력하고 유용한 효과를 얻을 수 있다. 시퀀스 다이어그램은 우리가 메시지에 집중할 수 있도록 해주며 첫번째로 통과시켜야하는 테스트의 합리적인 의도를 형성할 수 있게 해준다.

관심을 객체에서 메시지로 옮겨 퍼블릭 인터페이스 기반으로 어플리케이션을 디자인하는데 집중해야한다.

<br>

## 자신의 인터페이스를 드러내는 코드 작성하기

다음은 인터페이스를 만들 때 염두에 두어야하는 기본적인 원칙들이다.

### 명시적인 인터페이스 만들기

퍼블릭 인터페이스는 다음과 같아야한다.

- 일반적인 의미, 엄밀하고 명시적으로 규정되어 있어야 한다.
- 어떻게보다는 어떤 것에 대해 말해야 한다.
- 예측할 수 있는 한도에서나마 바뀌지 않을 이름을 지어야한다.
- 추가적인 인자를 해시로 받아라.

퍼블릭 인터페이스 뿐만 아니라 프라이빗 메서드 또한 의도를 가지고 명시적으로 만드는 것이 좋다.

protected, private 키워드를 사용한다는 의미는 다음과 같다.

- 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿는다.
- 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야한다.

### 다른이의 퍼블릭 인터페이스를 존중하자

다른 클래스와 협업할 떄는 클래스의 퍼블릭 인터페이스만 사용하도록 노력해야 한다. 디자인이 다른 클래스의 프라이빗 메서드를 사용하도록 유도한다면 디자인에 대해 다시 생각하고 다른 대안을 찾아야한다.

코드가 프라이빗 인터페이스에 의존하고 있으면 변화에 영향을 받을 위험이 증가한다. 외부 프레임워크에 프라이빗 메서드에 대한 의존성은 최대한 피해야한다.

### 프라이빗 인터페이스를 의존할 떄는 특별히 주의를 기울여야한다.

### 최소한의 맥락 속에 위치시키기

퍼블릭 인터페이스를 구성할 때는 다른 객체와 연계되어 있는 맥락을 최소화하는 방향을 염두에 두어야한다. 어떤 것과 어떻게의 사이의 구분을 기억해 송신자가 원하는 것을 클래스의 요청할 때 우리가 작성한 클래스의 구현과 작동 방식에 대해 몰라도 되는 퍼블릭 메서드를 작성하자.

<br>

## 데메테르의 원칙

데메테르의 원칙은 객체들의 결합도를 낮추면서 코딩할 수 있도록 해주는 규칙이다.

### 데메테르의 원칙 정의

데메테르의 원칙은 메서드가 메시지를 전송하지 말 것을 요구한다. 메시지를 전달받은 객체가 바로 이어 다른 타입의 객체에서 메시지를 전달하는 것을 금지한다.

'바로 옆에 있는 이웃하고만 소통하라', '점을 하나만 사용하라'로 표현할 수도 있다.

### 위반의 결과

```js
costomer.bicycle.wheel.tire; // #1
costomer.bicyle.wheel.rotate(); // #2
hash.keys.sort.join(', '); // #3
```

`#1`, `#2` 이 두 코드는 먼 곳에 있는 어트리뷰트를 가져오고 멀리 있는 행동을 호출한다. 이 경우 데메테르의 원칙을 따르려면 중간에 낀 객체를 명시적으로 표시하고 꼭 필요할 때만 목록을 수정하는 것이다.

`#3`은 String의 Enumerable을 반환하며 중간에 낀 객체들은 모두 같은 타입을 반환하고있다. 따라서 데메테르 원칙을 위반한 것은 아니다.

이 원칙은 자체로 완결적인 것이 아니며 어기는 것이 말이 되는 경우도 있지만 이 원칙을 따르는 것이 어플리케이션의 유연성을 높이고 유지보수를 쉽게 해줄 것이다.

### 데메테르의 원칙을 위반하지 않기

데메테르의 원칙을 피하기 위한 방법중 하나는 위임을 사용하는 것이다. 메시지 연쇄에 포함되어 있는 지식을 캡슐화 하거나 감춘 레퍼 메서드를 통해 위임할 수 있다.

### 데메테르의 원칙에 귀 귀울이기

데메테르의 원칙은 위임을 많이 사용하자를 말하는 것이 아니다. 메시지 연쇄는 우리가 이미 잘 알고 있는 객체로부터 영향을 받을 때 만들어진다. 이미 알고 있는 객체의 퍼블릭 인터페이스에 익숙하기 때문에 긴 메시지 연쇄를 통해 멀리 있는 행동에 접근하곤 한다.

이질적인 객체를 사이에두고 먼곳에 접근하는 행동은 강하게 결합되어 있으며 한 부분을 변경하면 다른 부분도 변경해야하는 위험성이 크다. 또한 객체를 다른 맥락에서 사용할 수 없을 수 있다.

메시지 기반의 관점을 취하면 새로운 메시지를 발견할 수 있고 이 메시지가 곧 퍼블릭 인터페이스가 된다. 그리고 이 퍼블릭 인터페이스를 정의할 새로운 객체를 발견할 수 있다.
