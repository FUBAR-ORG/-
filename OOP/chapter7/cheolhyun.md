# 모듈을 통한 역할 공유

> 이 장은 디자인은 미래를 예측하지 말라고 했는데 왜 미래를 예측하는 예시로 시작할까?

- 상속을 사용해서 얻을 수 있는 이점을 최대한 누리려면 상속 코드를 작성하는 법 뿐 아니라 언제 작성하면 좋을 지도 알아야 함.
- 고전정 상속은 여러 선택지 중 하나일 뿐이며, 상속으로 해결할 수 있는 문제는 다른 방식으로 해결할 수 있음.

> 모듈(`module`)은 상속의 기술을 이용해서 역할(`role`)을 공유하는 또 다른 방법.

## 역할 이해하기

- 간혹 클래스와 아무 상관 없는 공통의 행동을 공유하는 경우가 발생.
  > 이 행동은 객체가 수행하는 역할(`role`).
- 별 연관이 없는 객체가 서로 비슷한 역할을 수행하기 시작할 때 이 객체들은 주어진 역할을 수행하면서 누군가와 관계를 맺음.
- 이 관계는 잘 안 보이지만 분명히 존재하며, 역할을 사용하다보면 객체 간의 의존성 생성.

### 역할 찾기

- 오리 타입은 하나의 역할이고, 퍼블릭 인터페이스를 구현하고 있는 객체가 이 역할을 수행.
- 퍼블릭 인터페이스를 구현하고 있기 때문에 다른 객체는 모두 해당 역할이라고 생각하고 함께 협업.
  > 실제로 어떤 클래스에 속하는지 신경 쓸 필요 없음.
- 역할을 수행하기 위해서는 자신만의 메서드. 즉, 메서드 시그니처(`method signature`)만 공유하고 코드를 공유하지 않아도 됨.
- 이상적으로, 코드는 단 한 곳에 정의되어 있고 오리 타입처럼 행동하며 주어진 역할을 수행하는 객체가 사용해야 함.
- 여러 객체지향 언어들은 메서드의 묶음에 이름을 부여하고 관리할 수 있는 방법 제공.
- 이 묶음은 클래스로부터 독립적이며 어느 객체에든 녹아들(`mix in`) 수 있음.
  > 이를 모듈이라 함.
- 메서드는 모듈 속에서 정의되고 어느 객체든 이 모듈을 추가 가능.

> 모듈은 서로 다른 클래스에 속한 객체가 한 덩어리의 코드를 이용해서 같은 역할을 수행할 수 있는 최고의 방법을 제공.

- 객체가 모듈을 인클루드(`include`)하면 객체는 이 모듈이 정의하고 있는 메서드를 자동화된 위임(`automatic delegation`)을 통해 모두 사용할 수 있게 됨.
- 객체가 반응할 수 있는 메세지.
  - 스스로가 구현하고 있는 메세지.
  - 상속 관계에서 자기보다 상위에 있는 모든 객체가 구현하고 있는 메세지
  - 자기가 인클루드한 모든 모듈이 구현하고 있는 메세지
  - 상속 관계에서 자기보다 상위에 있는 모든 객체가 인클루드하고 있는 모든 모듈이 구현하고 있는 메세지

### 책임 관리하기

- 문제 제시(여행 스케줄을 짤 때 발생할 수 있는 문제)

  - 여행은 일정 시간동안 진행.
  - 여행에는 자전거, 정비공, 자동차가 필요.
  - 자전거, 정비공, 자동차는 같은 시간에 두 장소에 존재할 수 없음.
  - 여행과 여행 사이에 자전거는 하루, 자동차는 사흘, 정비공은 나흘은 쉬어야 함.

  > 패스트핏은 이 모든 것의 스케줄을 관리하고 있어야만 적절한 스케줄을 짤 수 있음.

- `Schedule` 클래스가 있다고 가정.

  - `Schedule` 클래스의 메서드

    ```js
    scheduled(target, starting, ending);
    add(target, starting, ending);
    remove(target, starting, ending);
    ```

    - `target`: 확인할 대상
    - `starting`: 시작일
    - `ending`: 종료일

  - 이 코드에는 여행 시작 전 필요한 준비 시간(`lead time`)이 빠져 있음.

    - `Schedule` 클래스가 준비 시간을 알고 있고, 준비 시간 관리를 책임지는 형태로 작성.
    - 이 경우 `Schedule`은 너무 많은 것을 알고 있음.

    > 우리가 어떤 메세지를 전송해야 할지 알기 위해 클래스를 체크하는 패턴.

> `Schedule`은 다른 클래스의 세부사항에 대해 모르는 채로 그저 메세지를 전송해야 함.

### 불필요한 의존성 제거하기

- 특정 변수의 값을 무엇으로 할지 결정하기 위해 여러 클래스의 이름을 확인하는 패턴은, 특정 변수를 메세지로 바꾸어야 함.

> 입력 받은 객체에게 전송하는 메세지로 변경

#### `Schedulable` 오리 타입 찾아내기

- `schedulable` 메서드가 클래스를 확인하는 부분을 제거하고, 인자로 넘어온 `target`들에게 `lead_days` 메세지를 전송하도록 바뀐 모습.
- 이 변경을 통해 객체의 클래스를 확인하는 `if` 문은 그 객체에게 보내는 메세지로 대체.
- 코드는 좀 더 단순해졌고, 정확한 준비 기간을 알고 있어야하는 책임 역시 마지막 객체가 갖게 됨.
- 마지막 객체야 말로 정확한 답변을 가지고 있는 객체이며, 그 책임을 담당해야하는 객체.
- `Schedule`은 `lead_days` 메세지를 자신의 `target`에게 전송하고 있고, `target`은 특정 클래스의 인스턴스가 아님.
- `Schedule`은 `target`의 클래스에 전혀 관심이 없고, 그저 `target`이 `lead_days` 메세지에 반응할 수 있기를 믿음.(`schedulable` 인 듯 행동하리라 믿음.)

> `Schedulable`이라는 오리 타입을 발견함.  
> 이 오리 타입은 `lead_days`를 필수적으로 구현하고 있어야 하지만 그 외에는 코드를 공유하지 않음.

#### 객체가 자기 스스로를 표현할 수 있게 하기

- 시작 객체(`instigator`)는 `target`의 `schedulable` 여부를 확인하는 메세지를 `target`이 아닌 `Schedule`에게 전송.
- 이는 시작 객체가 `Schedule`을 알아야 한다고 강제하는 것이고 `Schedule`에 의존하게 만듬.
- `target`도 `schedulable` 메서드에 반응할 수 있어야 하고, `Schedule` 역할의 인터페이스에는 `schedulable` 메서드가 추가되어야 함.

### 구체적인 코드 작성하기

- 실제 코드를 작성하기 전에, 코드가 무엇을 해야 하는지, 코드를 어디에 두어야 하는지 결정해야 함.
- 두 결정을 분리하여 다룸.
  - 임의의 구체 클래스를 하나 선택하고 여기에 `schedulable` 메서드를 구현.
  - 구체 클래스가 사용할 수 있는 코드가 완성되면 모든 코드를 재배치해서 `Schedulable`이 사용할 수 있도록 리팩터링.

```js
class Schedule {
  scheduled(schedulable, start_date, end_date) {
    console.log(
      `This ${schedulable.class} is not scheduled\n between ${start_date} and ${end_date}`
    );
    return false;
  }
}

class Bicycle {
  constructor(args = {}) {
    this.schedule = args.schedule || new Schedule();
  }

  schedulable(start_date, end_date) {
    this.scheduled(stare_date + this.lead_days, end_date);
  }

  scheduled(start_date, end_date) {
    this.schedule.scheduled(start_date, end_date);
  }

  get lead_days() {
    return 1;
  }
}

const starting = new Date('2015/09/04');
const ending = new Date('2015/09/10');

const bike = new Bicycle();
bike.schedulable(starting, ending);
```

- 이 코드는 `Schedule`이 누구인지, `Bicycle` 안에서 어떤 일을 하는지를 밖으로 드러내지 않음.

> `Bicycle`과 협업하는 객체는 더이상 `Schedule`의 존재도 그 행동도 알 필요가 없음.

### 추상화하기

- `JavaScript` 모듈 생성 코드 예제 1

  ```js
  function moduleName() {
    this.method = this.method ?? function () {};
  }

  class ClassName {
    constructor() {
      moduleName.call(ClassName.prototype);
    }
  }
  ```

- `JavaScript` 모듈 생성 코드 예제 2

  ```js
  function includeModule(obj, mod) {
    for (const key in mod) {
      if (obj.prototype[key] === undefined) {
        obj.prototype[key] = mod[key];
      }
    }
  }

  const moduleName = {
    method() {},
  };

  class ClassName {
    constructor() {
      iuncludeModule(ClassName, moduleName);
    }
  }
  ```

- `Bicycle` 만 `schedulable`을 갖고 있으면 안되고, `Mechanic`, `Vehicle`도 같은 역할을 수행하며 같은 행동을 갖고 있어야 함.

```js
function Schedulable() {
  // tihs.s; // attr_writer
  this.schedule = function () {
    return this.s ?? new Schedule();
  };

  this.schedulable = function (start_date, end_date) {
    this.scheduled(stare_date - this.lead_days, end_date);
  }
  this.scheduled(start_date, end_date) {
    this.schedule.scheduled(start_date, end_date);
  }

  this.lead_days = this.lead_days ?? 0;
}

class Bicycle {
  constructor() {
    Schedulable.call(Bicycle.prototype);
  }

  get lead_days() {
    return 1;
  }
}

class Vehicle {
  constructor() {
    Schedulable.call(Vehicle.prototype);
  }

  get lead_days() {
    return 3;
  }
}

class Mechanic {
  constructor() {
    Schedulable.call(Mechanic.prototype);
  }

  get lead_days() {
    return 4;
  }
}

const starting = new Date('2015/09/04');
const ending = new Date('2015/09/10');

const bike = new Bicycle();
bike.schedulable(starting, ending);

const vehicle = new Vehicle();
vehicle.schedulable(starting, ending);

const mechanic = new Mechanic();
mechanic.schedulable(starting, ending);
```

- 새로운 `Schedulable` 모듈은 `Bicycle` 클래스에서 공통 행동을 뽑아내 추상화시킨 것.
- 시작 객체가 `Schedule`에 의존하고 있었음.

  - 이는 애플리케이션의 여러 곳에서 `Schedule`에 대한 지식이 흩뿌려짐.

  > `Schedule`에 대한 의존성이 `Schedulable`로 옮겨감.

- 기존 `lead_days`는 `Bicycle`에만 적용되는 숫자.
  - 모듈은 기본 값 `0`을 반환하고, 템플릿 메서드 패턴을 따르는 훅 메서드로 정의, 이 훅 메서드를 재정의하여 자신만의 특수한 행동 추가.

> `Schedulable` 속에 있는 코드는 추상화되었고, 템플릿 메서드 패턴을 이용해서 객체들이 자신만의 알고리즘에 자신만의 특수한 내용을 추가할 수 있도록 해줌.  
> `schedulable` 메세지는 자동으로 `Schedulable` 모듈로 전달.  
> 메서드 탐색(`method lookup)`이 상속과 모듈 동일한 방식으로 진행되기 때문에 코딩 방식 역시 동일.  
> 상속인 것과 상속인 것처럼 행동하는 것의 차이는 분명 중요.  
> 이 기술이 비슷한 이유는 둘 모두 자동화된 메세지 전달(`automatic message delegation`)에 기반하고 있기 때문.

### 메서드를 찾아 올라가기

#### 아주 단순한 설명

- 객체가 메세지를 수신하면 객체지향 언어는 먼저 이 클래스에서 메서드 구현을 찾아봄.
- 이 클래스에서 메세지를 구현하고 있지 않다면 상위 클래스를 연쇄를 타고 찾아봄.
- 이는 최상위 클래스에 도달할 때까지 진행.

#### 조금 더 정확한 설명

- `Bicycle`이 `Schedulable` 모듈을 인클루드하면 이 모듈에서 정의된 모든 메서드들이 `Bicycle`이 반응할 수 있는 메세지 모음에 추가.
- 모듈의 메서드들은 메서드 탐색 경로에서 `Bicycle`이 정의한 메서드들 바로 위에 자리를 잡음.
- 상위 클래스가 바뀌지 않았지만, 탐색의 관점에서는 바뀐 것처럼 보일 수 있음.
- `Schedulable` 모듈이 이미 정의하고 있는 메서드를 `Bicycle`이 구현한다면, `Bicycle`의 구현이 `Schedulable`의 것을 재정의(`override`)하게 됨.
- 모듈은 상위 클래스와 하위 클래스 중간에 위치하게 됨.

#### 거의 완벽한 설명

- 매우 긴 상위 클래스의 연쇄를 가지고 있고, 상위 클래스가 여러 개의 모듈을 인클루드하고 있는 경우, 모듈들은 인클루드된 순서와는 반대로 메서드 탐색 경로에 추가됨.
- 가장 나중에 인클루드된 모듈이 메서드 탐색 경로에서는 가장 먼저 등장.(`JavaScript`에서 이걸 구현 못함.)

> 모듈을 불러오는 모든 방법들은 메서드 모음을 메서드 탐색 경로의 특정 위치, 애매하지 않고 명확히 정해져 있는 위치에 올려 놓음.

> 사용하기 전 객체의 위계 관계(`Object hierarchy`)를 먼저 살펴볼 필요가 있음.

## 역할의 행동 상속받기

- 다른 모듈을 인클루드 하는 모듈, 다른 모듈이 정의하고 있는 메서드를 재정의해 버리는 모듈, 매우 길게 늘어선 상속 관계를 만들어 놓고 이 관계 중간 여러 층위의 클래스들에 이 모듈들을 인클루드.
- 굉장히 강력하지만 굉장히 위험한 구조.
- 강력한 힘을 사용해 객체들 사이의 간단한 구조를 만들고, 간단한 구조를 통해 애플리케이션의 문제를 우아하게 해결할 수 있음.

> 제대로 상속받을 수 있는 코드를 작성하는 것이 키 포인트.

---

## 상속받을 수 있는 코드 작성하기

### 안티 패턴 알아채기

- 상속을 적용하면 좋을 것 같은 패턴

  1. `type`이나 `category`와 같은 이름을 가진 변수가 있고, 이 변수를 통해 `this`에 어떤 메세지를 전송할지 결정하는 경우.

  - 이런 변수는 연관되어 있지만 미묘하게 다른 두 가지 타입을 동시에 품고 있음.
  - 새로운 타입을 추가할 때마다 코드를 수정.
  - 공통된 코드는 추상화된 상위 클래스로 올리고, 타입 별로 하위 클래스 작성.
  - 하위 클래스를 통해 하위 타입(`sub type`)을 만들고, 이런 하위 클래스는 기존의 코드를 수정하지 않고도 상속 관계 확장 가능.

  > 고전적 상속을 통해 정리할 수 있음.

  2. 객체의 클래스를 확인하고 어떤 메세지를 전송할지 판단하는 경우.

  - 새로운 클래스나 수신자를 만들 때마다 코드를 수정.
  - 모든 수신자가 같은 역할을 수행하고 있다고 생각할 수 있음.
  - 이 역할을 오리 타입으로 만들어야 하고, 수신자는 오리 타입의 인터페이스를 구현하고 있어야 함.
  - 송신자 객체는 모든 수신자에게 하나의 동일한 메세지만 전송.

  > 인터페이스와 행동을 공유하는 오리 타입, 모듈을 통해 정리할 수 있음.

### 추상화된 코드를 모두 사용하기

- 추상화된 상위 클래스에 포함된 모든 코드는 이 클래스를 상속 받는 모든 하위 클래스에도 적용될 수 있어야 함.
- 몇몇 하위 클래스만 사용하는 코드가 상위 클래스에 포함되어 있으면 안됨.(모듈 또한 마찬가지, 모듈을 사용하는 모든 객체에 적용.)
- 잘못된 추상화는 코드를 상속받은 객체가 잘못된 행동을 품고 있게 함.(이를 일시적으로 회피하려는 시도로 인해 코드가 병들 수 있음.)

> 상속받은 메서드를 재정의해서 `does not implemented`와 같은 에러를 발생시키는 하위 클래스가 있다면 상속 관계의 문제점을 인식해야 함.  
> 코드를 공통으로 사용할 만한 추상화된 코드가 없다면, 주어진 디자인 이슈의 해결책은 상속이 아님.

### 약속을 존중하라

- 하위 클래스는 상위 클래스를 대체할 수 있는 형태가 되어야 함.(대체 가능성)
- 대체 가능성(`substitutability`)은 객체들이 우리가 예측할 수 있게 행동할 때만 보장.
- 하위 클래스는 자신의 인터페이스를 충실히 따르는 것이 우리의 기대 대로 행동하는 것.
- 하위 클래스에게 기대하는 것

  - 이들은 인터페이스에서 정의하고 있는 모든 메서드에 반응.
  - 같은 종류의 입력에 대해 같은 종류의 출력을 내놓아야 함.
  - 자신의 타입을 확인하게 만들어서는 안됨.
  - 타입을 확인해서 이 클래스를 어떻게 다루어야 하는지 판단하거나 어떤 출력을 기대할 수 있는지 판단하게 만들어서는 안됨.

- 상위 클래스가 입력 받는 인자와 반환되는 값을 제한해도 하위 클래스는 약속을 깨지 않고 조금 덜 제한적으로 어느정도 자유를 누릴 수 있음.

> 이런 기대의 약속을 깬 하위 클래스는 특별하며, 자신의 상위 클래스를 대체하지 못함.  
> 상위 클래스의 한 종류가 아님을 말하므로, 전체 상속 관계의 구성을 점검해 보아야 함.

#### 리스코프 치환 원칙

> `q(x)`를 자료형 `T`의 객체 `x`에 대해 증명할 수 있는 속성이라고 하자. 그렇다면 `S`가 `T`의 하위형이라면 `q(y)`는 자료형 `S`의 객체 `y`에 대해 증명할 수 있어야 한다.

- 바바라 리스코프(`Barbara Liskov`)가 주장한 `SOLID` 디자인에서 `L`에 해당하는 원칙.
- 약속을 존중하는 말이 곧 리스코프 치환 원칙을 따른다는 것.
- 타입 시스템이 정상적으로 작동하려면 상위 타입(`supertype`)은 자신의 하위 타입(`subtype`)으로 치환될 수 있어야 함.
- 즉, 상위 클래스가 사용될 수 있는 곳이라면 어디든 하위 클래스를 사용할 수 있어야 함.
- 모듈을 인클루드 하고 있는 객체라면 누구나 모듈이 제공하는 역할을 수행할 수 있어야 함.

### 템플릿 메서드 패턴 사용하기

- 템플릿 메서드 패턴은 상속받을 수 있는 코드를 작성하기 위한 핵심적인 기술.
- 추상적인 것과 구체적인 것을 구분할 수 있게 해줌.
- 추상적인 코드가 알고리즘을 구현하며, 추상화를 상속받은 구체 클래스가 주어진 템플릿 메서드를 재정의하여 자신의 특수한 행동을 추가.

> 템플릿 메서드는 알고리즘의 변경되는 지점들을 표현하고, 템플릿 메서드를 통해 어떤 내용이 변하고, 변하지 않는 지 명시적으로 선택.

### 한 발 앞서 클래스 사이의 결합 깨뜨리기

> 상속받은 클래스가 `super`를 전송해야 하는 코드는 지양.

- 훅 메서드를 이용하면 하위 클래스가 개입할 수 있는 여지를 제공하면서 동시에 하위 클래스에게 추상적인 알고리즘에 대해 알아야 하는 책임을 제거 가능.
- 그 속성 상속은 주어진 구조와 코드의 배치 형태에 대해 강한 의존성을 띔.
- 하위 클래스가 `super`를 전송해야 하는 코드는 여기에 또 다른 의존성을 추가.
- 훅 메서드는 `super`를 전송해야 하는 문제를 해결.
  - 하지만 옆 층위의 객체와의 관계에서만 사용 가능.
  - 하위 클래스를 상속받는 또 다른 하위 클래스에서는 주어진 문제가 다시 발생.
  - 이 최하위 클래스가 자신 만의 고유 정보를 상위 클래스들이 제공하는 결과와 합치려면 `super`를 전송.

### 상속 관계(상속 구조)를 낮게 만들기

- 훅 메서드의 한계는 상속 관계의 높이를 낮게 만들어야 하는 이유 중 하나.
- 모든 상속 관계는 피라미드, 트리 형태를 띔.
- 높이가 낮고 너비가 좁은 구조는 이해하기 쉬움

|             |                너비가 좁음                 |                       너비가 넓음                       |
| :---------: | :----------------------------------------: | :-----------------------------------------------------: |
| 높이가 낮음 |               이해하기 쉬움                |                     조금 더 복잡함                      |
| 높이가 높음 | 보다 이해하기 어렵고, 점점 넓어지려는 경향 | 이해하기 어렵고, 유지보수 비용도 비쌈(피하는 것이 좋음) |

- 높은 상속 관계의 문제는 메세지 탐색 경로가 매우 길다는 것.
- 메세지가 이 경로를 따라갈 때 중간에 만나는 수 많은 객체들이 새로운 행동을 추가할 수 있다는 점.
- 객체는 자신보다 위에 있는 모든 것에 의존하고 있기 때문에 높은 상속 관계는 이미 수 많은 붙박이 의존성(`built-in dependencied`)를 가지고 있음.
  - 이 의존성은 언제든지 변경 가능.
- 높은 상속 관계의 또 다른 문제는 대부분 구조의 가장 윗단과 가장 아랫단에만 익숙하다는 점.
- 상속 탐색 경로의 경계에 위치한 행동들만 이해하고 있는 경향.
- 중간에 끼어 있는 클래스에 대한 이해도가 낮으며, 이를 수정하면 에러가 만들어질 가능성이 매우 높음.

## 요약

- 같은 역할을 수행하는 객체가 행동을 공유해야할 때 모듈을 사용.
- 모듈에 정의된 코드는 어떤 객체에든 추가 가능.(클래스, 인스턴스, 또 다른 모듈)
- 클래스가 모듈을 인클루드하면 이 모듈 속의 메서드들은 상속을 통해 얻은 메서드들과 동일한 메서드 탐색 경로에 포함됨.
  - 탐색 경로에 끼워 넣었기 때문에 모듈을 이용한 코딩 기술과 상속을 이용한 코딩 기술이 비슷함.
  - 특수한 행동을 추가하기 위해선 템플릿 메서드 패턴과 훅 메세지 사용.
    > 알고리즘을 몰라도 괜찮게 해주어야 함.
- 객체가 다른 곳에서 정의된 행동을 가져왔다면, 이 객체는 암묵적으로 어떤 종류의 약속(리스코프 치환원칙)을 따름.
  - 상위 타입은 자신의 하위 타입으로 치환될 수 있음.

> 객체는 자기 자신이 누구라고 밝힌 그대로 행동해야 함.
