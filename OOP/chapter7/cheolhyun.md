# 모듈을 통한 역할 공유

> 이 장은 디자인은 미래를 예측하지 말라고 했는데 왜 미래를 예측하는 예시로 시작할까?

- 상속을 사용해서 얻을 수 있는 이점을 최대한 누리려면 상속 코드를 작성하는 법 뿐 아니라 언제 작성하면 좋을 지도 알아야 함.
- 고전정 상속은 여러 선택지 중 하나일 뿐이며, 상속으로 해결할 수 있는 문제는 다른 방식으로 해결할 수 있음.

> 모듈(`module`)은 상속의 기술을 이용해서 역할(`role`)을 공유하는 또 다른 방법.

## 역할 이해하기

- 간혹 클래스와 아무 상관 없는 공통의 행동을 공유하는 경우가 발생.
  > 이 행동은 객체가 수행하는 역할(`role`).
- 별 연관이 없는 객체가 서로 비슷한 역할을 수행하기 시작할 때 이 객체들은 주어진 역할을 수행하면서 누군가와 관계를 맺음.
- 이 관계는 잘 안 보이지만 분명히 존재하며, 역할을 사용하다보면 객체 간의 의존성 생성.

### 역할 찾기

- 오리 타입은 하나의 역할이고, 퍼블릭 인터페이스를 구현하고 있는 객체가 이 역할을 수행.
- 퍼블릭 인터페이스를 구현하고 있기 때문에 다른 객체는 모두 해당 역할이라고 생각하고 함께 협업.
  > 실제로 어떤 클래스에 속하는지 신경 쓸 필요 없음.
- 역할을 수행하기 위해서는 자신만의 메서드. 즉, 메서드 시그니처(`method signature`)만 공유하고 코드를 공유하지 않아도 됨.
- 이상적으로, 코드는 단 한 곳에 정의되어 있고 오리 타입처럼 행동하며 주어진 역할을 수행하는 객체가 사용해야 함.
- 여러 객체지향 언어들은 메서드의 묶음에 이름을 부여하고 관리할 수 있는 방법 제공.
- 이 묶음은 클래스로부터 독립적이며 어느 객체에든 녹아들(`mix in`) 수 있음.
  > 이를 모듈이라 함.
- 메서드는 모듈 속에서 정의되고 어느 객체든 이 모듈을 추가 가능.

> 모듈은 서로 다른 클래스에 속한 객체가 한 덩어리의 코드를 이용해서 같은 역할을 수행할 수 있는 최고의 방법을 제공.

- 객체가 모듈을 인클루드(`include`)하면 객체는 이 모듈이 정의하고 있는 메서드를 자동화된 위임(`automatic delegation`)을 통해 모두 사용할 수 있게 됨.
- 객체가 반응할 수 있는 메세지.
  - 스스로가 구현하고 있는 메세지.
  - 상속 관계에서 자기보다 상위에 있는 모든 객체가 구현하고 있는 메세지
  - 자기가 인클루드한 모든 모듈이 구현하고 있는 메세지
  - 상속 관계에서 자기보다 상위에 있는 모든 객체가 인클루드하고 있는 모든 모듈이 구현하고 있는 메세지

### 책임 관리하기

- 문제 제시(여행 스케줄을 짤 때 발생할 수 있는 문제)

  - 여행은 일정 시간동안 진행.
  - 여행에는 자전거, 정비공, 자동차가 필요.
  - 자전거, 정비공, 자동차는 같은 시간에 두 장소에 존재할 수 없음.
  - 여행과 여행 사이에 자전거는 하루, 자동차는 사흘, 정비공은 나흘은 쉬어야 함.

  > 패스트핏은 이 모든 것의 스케줄을 관리하고 있어야만 적절한 스케줄을 짤 수 있음.

- `Schedule` 클래스가 있다고 가정.

  - `Schedule` 클래스의 메서드

    ```js
    scheduled(target, starting, ending);
    add(target, starting, ending);
    remove(target, starting, ending);
    ```

    - `target`: 확인할 대상
    - `starting`: 시작일
    - `ending`: 종료일

  - 이 코드에는 여행 시작 전 필요한 준비 시간(`lead time`)이 빠져 있음.

    - `Schedule` 클래스가 준비 시간을 알고 있고, 준비 시간 관리를 책임지는 형태로 작성.
    - 이 경우 `Schedule`은 너무 많은 것을 알고 있음.

    > 우리가 어떤 메세지를 전송해야 할지 알기 위해 클래스를 체크하는 패턴.

> `Schedule`은 다른 클래스의 세부사항에 대해 모르는 채로 그저 메세지를 전송해야 함.

### 불필요한 의존성 제거하기

- 특정 변수의 값을 무엇으로 할지 결정하기 위해 여러 클래스의 이름을 확인하는 패턴은, 특정 변수를 메세지로 바꾸어야 함.

> 입력 받은 객체에게 전송하는 메세지로 변경

#### `Schedulable` 오리 타입 찾아내기

- `schedulable` 메서드가 클래스를 확인하는 부분을 제거하고, 인자로 넘어온 `target`들에게 `lead_days` 메세지를 전송하도록 바뀐 모습.
- 이 변경을 통해 객체의 클래스를 확인하는 `if` 문은 그 객체에게 보내는 메세지로 대체.
- 코드는 좀 더 단순해졌고, 정확한 준비 기간을 알고 있어야하는 책임 역시 마지막 객체가 갖게 됨.
- 마지막 객체야 말로 정확한 답변을 가지고 있는 객체이며, 그 책임을 담당해야하는 객체.
- `Schedule`은 `lead_days` 메세지를 자신의 `target`에게 전송하고 있고, `target`은 특정 클래스의 인스턴스가 아님.
- `Schedule`은 `target`의 클래스에 전혀 관심이 없고, 그저 `target`이 `lead_days` 메세지에 반응할 수 있기를 믿음.(`schedulable` 인 듯 행동하리라 믿음.)

> `Schedulable`이라는 오리 타입을 발견함.  
> 이 오리 타입은 `lead_days`를 필수적으로 구현하고 있어야 하지만 그 외에는 코드를 공유하지 않음.

#### 객체가 자기 스스로를 표현할 수 있게 하기

- 시작 객체(`instigator`)는 `target`의 `schedulable` 여부를 확인하는 메세지를 `target`이 아닌 `Schedule`에게 전송.
- 이는 시작 객체가 `Schedule`을 알아야 한다고 강제하는 것이고 `Schedule`에 의존하게 만듬.
- `target`도 `schedulable` 메서드에 반응할 수 있어야 하고, `Schedule` 역할의 인터페이스에는 `schedulable` 메서드가 추가되어야 함.

### 구체적인 코드 작성하기

- 실제 코드를 작성하기 전에, 코드가 무엇을 해야 하는지, 코드를 어디에 두어야 하는지 결정해야 함.
- 두 결정을 분리하여 다룸.
  - 임의의 구체 클래스를 하나 선택하고 여기에 `schedulable` 메서드를 구현.
  - 구체 클래스가 사용할 수 있는 코드가 완성되면 모든 코드를 재배치해서 `Schedulable`이 사용할 수 있도록 리팩터링.

```js
class Schedule {
  scheduled(schedulable, start_date, end_date) {
    console.log(
      `This ${schedulable.class} is not scheduled\n between ${start_date} and ${end_date}`
    );
    return false;
  }
}

class Bicycle {
  constructor(args = {}) {
    this.schedule = args.schedule || new Schedule();
  }

  schedulable(start_date, end_date) {
    this.scheduled(stare_date - this.lead_days, end_date);
  }

  scheduled(start_date, end_date) {
    this.schedule.scheduled(this start_date, end_date);
  }

  get lead_days() {
    return 1;
  }
}

const starting = new Date('2015/09/04');
const ending = new Date('2015/09/10');

const bike = new Bicycle();
bike.schedulable(starting, ending);
```

- 이 코드는 `Schedule`이 누구인지, `Bicycle` 안에서 어떤 일을 하는지를 밖으로 드러내지 않음.

> `Bicycle`과 협업하는 객체는 더이상 `Schedule`의 존재도 그 행동도 알 필요가 없음.

### 추상화하기

### 메서드를 찾아 올라가기

#### 아주 단순한 설명

#### 조금 더 정확한 설명

#### 거의 완벽한 설명

## 역할의 행동 상속받기

---

## 상속받을 수 있는 코드 작성하기

### 안티 패턴 알아채기

### 추상화된 코드를 모두 사용하기

### 약속을 존중하라

#### 리스코프 치환 원칙

### 템플릿 메서드 패턴 사용하기

### 한 발 앞서 클래스 사이의 결합 깨뜨리기

### 상속 관계(상속 구조)를 낮게 만들기

---

## 요약
