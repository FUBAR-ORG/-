# 3장 의존성 관리하기

메시지는 하나의 객체에서 시작되며 특정한 행동을 일으킨다. 이 행동은 객체 사이에 흩뿌려져 있기 때문에 행동을 유발하기 위해서는 객체는 그 행동을 상속 받거나 그 행동을 알고 있는 객체에 대해 알아야한다.

이것이 바로 의존성이다. 제대로 디자인되어 단일 책임을 가지고 있는 객체들이 서로 협업하려면 객체는 서로 다른 객체에 대한 지식이 있어야하며 이 지식은 의존성을 만들어낸다. 이러한 의존성을 제대로 관리하지 못하면 어플리케이션은 엉망이 된다.

<br>

## 의존성 이해하기

하나의 객체를 수정했을 때 다른 객체들을 뒤따라 수정해야한다면 수정해야하는 객체들은 수정한 객체에 의존적이다.

### 의존성이 있다는 것을 알기

객체는 다음과 같은 내용을 알고 있을 때 의존성을 갖는다.

- 클래스가 다른 클래스가 있다는 것을 알고 있다.
- 자신을 제외한 다른 객체에게 전송할 메시지의 이름을 알고 있다.
- 메시지가 필요로 하는 인자들 즉, 넘겨야 하는 인자를 알고 있다.
- 인자들을 전달하는 순서를 알고 있다.

어느 정도의 의존성이 생기는 것을 어쩔 수 없지만 불필요한 의존성은 코드를 덜 적절하게 만든다. 의존성은 수정을 강제하며 어플리케이션 전체에 영향을 끼칠 수 있다.

**우리는 클래스가 자신이 해야하는 일을 하기위한 최소한의 지식을 제외하고는 아무것도 모르도록 의존성을 관리하는 것이다.**

### 객체들 간의 결합

의존성은 객체를 결합시킨다. 의존성이 높은 객체, 즉 강하게 결합된 객체들은 하나인것처럼 행동한다.

강하게 결합된 객체들은 한 덩어리로 움직이고 하나를 수정하면 다른 것도 수정해야하기 때문에 이들 중 하나만 재사용하는 것은 불가능하다.

### 다른 의존성들

하나의 객체가 다른 객체에 대해 알고 있는데 이 다른 객체가 무언가를 알고 있는 또 다른 객체에 대해 알고 있는 경우, 쉽게 말해 여러개의 메시지가 여러 단계에 거쳐 연결되어 있는 메시지 체이닝은 모든 객체와 메시지들 사이에 의존성을 만들어 낸다.

이러한 추가적인 결합에 의한 의존성은 체이닝의 중간 객체가 변하면 첫 번째 객체에 수정을 강제할 가능성이 매우 높다. 이 경우 데메테르의 원칙이 위반 되었다고 말한다.

테스트는 코드를 참조하기때문에 테스트는 코드에 의존적이다. 코드와 지나치게 결합된 테스트는 코드의 수정이 뒤이어 테스트의 수정을 강제하는 의존성이다.

<br>

## 약하게 결합된 코드 작성하기

코드의 결합도를 낮춰 의존성을 줄여야한다.

### 의존성 주입하기

**'객체의 클래스가 무엇인지'가 중요한 것이 아니라 '우리가 전송하는 메시지가 무엇인지'가 중요하다.**

코드를 수정하지 않고 기존 코드를 재배치하는 것만으로 객체 사이의 결합을 없앨 수 있다.

### 의존성 격리시키기

불필요한 의존성을 모두 제거하면 좋겠지만 현실적으로 어렵다. 불필요한 의존성을 제거할 수 없는 경우라면 의존성을 클래스 안에서 격리시켜야 한다.

- 인스턴스 생성을 격리시키기: 클래스가 외부 객체를 참조하게 내버려두어선 안된다.
- 외부로 전송하는 메시지 중 위험한 것들을 격리시키기: 외부에 대한 의존성을 걷어내고 의존성을 클래스 내부의 메서드속에 캡슐화 시켜 놓으면 의존성을 줄일 수 있다.

### 인자 순서에 대한 의존성 제거하기

많은 메서드들은 인자들이 정해진 순서대로 전달되기를 기대한다. 이렇게 고정된 순서대로 넘겨진 인자들은 의존성을 만들어낸다.

이 경우 다음과 같은 방법으로 의존성을 줄일 수 있다.

- 초기화 인자로 해시를 사용하기
- 기본값 사용하기
- 멀티파라미터 초기화를 고립시키기

외부에 대한 의존성이 코드속으로 스며들게 하지말고 어플리케이션을 직접 통제할 수 있는 레퍼 메서드를 만들어서 어플리케이션을 보호해야 한다.

<br>

## 의존성의 방향 관리하기

의존성은 방향이 있다. 의존성을 어느 방향으로 하느냐에 따라 의존도가 달라진다.

### 의존성의 방향 바꾸기

의존성의 방향을 어떻게 설정하느냐에 따라 유지보수하기 쉬운 어플리케이션이 될 수도 있고 의존도가 큰 객체들로 이루어져 수정이 힘든 어플리케이션이 될 수도 있다.

### 의존성 방향 결정하기

**자기 자신보다 덜 변하는 것들에 의존하라**

요구사항이 자주 바뀌는 클래스, 추상 클래스보다 수정해야는 경우가 많은 구체 클래스, 의존성이 높은 클래스에는 의존해서는 안된다.

- 변경 가능성이 얼마나 높은지 이해하기
  - 빌트인 객체들은 사용자가 정의한 객체보다 변경될 가능성이 낮다. 이와 같이 다른 클래스와 비교해 얼마나 변경되지 않는가를 기준으로 순위를 매겨 이 순위를 의존성의 방향을 결정하는데 핵심적으로 이용해야한다.
- 구체적인 것과 추상적인 것을 인지하기
  - 추상이란 '모든 구체적으로부터 분리된'이라는 의미이다. 추상된 결과에 의존하는 것은 구체 클래스에 의존하는 것보다 훨씬 안전하다.
- 의존성이 높은 클래스 만들지 않기
- 문제가 되는 의존성 찾아내기
  - 클래스에 의존하고 있는 객체의 수, 요구사항 변경 가능성을 고려해 의존성을 찾아내야한다.
