# 단일 책임 원칙을 따르는 클래스 디자인하기

메시지와 클래스는 객체지향 시스템의 중요한 구성 요소이다.

- 메시징: 객체가 또 다른 객체의 인터페이스를 통해 어떤 행위를 하라고 명령하는 것
- 클래스: 특정 객체가 생성하기 위해 변수와 메서드를 정의하는 틀이며 멤버 변수와 메서드로 구성

우리는 **단순하며 제대로 작동하고 나중에 쉽게 수정할 수 있는 클래스**를 이용해 어플리케이션을 모델링 해야한다.

<br>

## 무엇을 클래스에 넣을것인가

### 메서드를 묶어 클래스로 만들기

메서드는 클래스 속에서 정의된다. 클래스는 상상의 범위 밖에서는 사고하기 힘든 하나의 박스를 만드는 것이다. 또한 변화를 가져가야할 순간이 왔을 때 변화를 잘 소화할 수 있는지를 결정하는 것이 바로 디자인이다.

**디자인이란 완벽함을 추구하는 것이 아닌 코드의 수정가능성을 보존하는 기술이다.**

### 수정하기 쉽도록 코드를 구성하기

*수정하기 쉽다*라는 표현의 정의는 다음과 같다.

- 수정이 예상치 못한 부작용을 발생시키지 않는다.
- 요구사항이 조금 변했을 때 연관된 코드들을 조금만 수정하면 된다.
- 현재 코드를 다시 사용하기 쉽다.
- 코드를 수정하는 가장 쉬운 방법은 이미 수정하기 쉬운 코드에 새로운 코드를 추가하는 것이다.

**TRUE** 코드란 당장의 요구사항을 충족하고 미래의 요구사항에도 대응할 수 있는 코드이며 자세한 내용은 다음과 같다.

- 투명하다(transparent): 수정된 코드 속, 코드와 관련된 코드 속에서 수정의 결과가 투명하게(transparently) 드러나야한다.
- 적절하다, 합리적이다(resonable): 모든 수정 비용은 수정 후 얻은 이득에 비례해야한다.
- 사용가능하다(usable): 예상치 못한 상황에서도 현재 코드를 사용할 수 있어야한다.
- 모범이 된다(exemplary): 코드 자체가 나중에 수정하는 사람이 위의 특징을 이어갈 수 있게 도와줘야한다.

**위와 같은 코드를 짜기 위한 첫 단추는 모든 클래스들이 잘 정의된 하나의 책임을 갖도록 하는 일이다.**

<br>

## 하나의 책임만을 지는 클래스 만들기

하나의 클래스는 최대한 작으면서 유용한 하나의 책임만 있어야한다. 각 클래스를 자전거와 자전거의 특정 부분들로 표현해보자.

### 자전거와 기어

우리는 자전거를 탈 때 상황에 따라 작은 기어와 큰 기어를 선택하며 이는 앞/뒤의 톱니바퀴 톱니 수의 비율로 표시해 사용한다.

기어를 클래스로 표현하면 다음과 같다.

```js
class Gear {
  constructor(chaninring, cog) {
    this.chaninring = chaninring;
    this.cog = cog;
  }

  ratio() {
    return this.chaninring / this.cog;
  }
}

const smallGear = new Gear(52, 11);
const bigGear = new Gear(30, 27);

smallGear.ratio();
bigGear.ratio();
```

기어 클래스는 앞 톱니바퀴, 뒷 톱니바퀴, 기어비 즉, 데이터와 행동 둘 다 가지고 있다. 따라서 기어는 클래스가 되기 충분하다.

기어 클래스에 기어와 바퀴 크기가 모두 다른 자전거를 비교하기 위해 사용하는 기어 인치라는 단위를 계산하는 메서드를 추가해보자.

```js
class Gear {
  constructor(chaninring, cog, rim, tire) {
    this.chaninring = chaninring;
    this.cog = cog;
    this.rim = rim;
    this.tire = tire;
  }

  ratio() {
    return this.chaninring / this.cog;
  }

  gearInches() {
    return this.ratio() * (this.rim + this.tire * 2);
  }
}

const gear = new Gear(52, 11, 26, 1.5);

gear.gearInches();
```

### 단일 책임 원칙은 왜 중요한가

쉽게 수정 가능한 어플리케이션은 재사용하기 쉬운 클래스로 구성되어 있다. 한 개 이상의 책임이 있는 클래스는 재사용이 어렵다. 클래스 속 책임들이 얽혀 있으면 유지보수가 어렵고 버그를 만들어 낸다.

### 클래스에게 하나의 책임만 있는지 알아보기

클래스가 진짜 하는 일이 무엇인가 알아내기 위해서는 클래스는 최대한 작으면서 유용한 것을 수행해야 한다는 것을 기억하면서 클래스의 책임을 한 문장으로 만들어 보는 것이다. 그 문장에 '그리고', '또는'이 들어가는 경우 두 가지 이상의 책임을 가지고 있을 가능성이 높다.

단일 책임 원칙(SRP)이란 클래스가 응집되어 있어야 하는 것 즉, 클래스 안의 모든 것들이 하나의 핵심 목표와 연관되어 있어야한다.

### 언제 디자인을 결정할지 판단하기

미래의 어떤 기능을 알지 못하는 준비 안된 상태에서 서둘러 디자인을 결정할 필요는 없다. 항상 나중에 코드를 수정할 때의 비용과 지금 코드를 수정할 때의 비용을 계산해 결정하고 당장의 필요와 미래 가능성 사이에서 고민해야한다.

**디자인 결정은 꼭 필요한 순간에, 그 순간이 제공하는 정보들을 가지고 해야한다.**

<br>

## 변화를 받아들일 수 있는 코드 작성하기

다음은 변화를 받아들일 수 있는 코드를 작성하기 위한 기술이다.

### 데이터가 아니라 행동에 기반한 코드를 작성하라

행동은 메서드 속에 담ㅇ겨 있고 메시징을 통해 실행된다. 반복하지 말 것(Don't Repeat Yourself, DRY), DRY한 코드는 클래스의 행동을 수정하기 위해 코드의 오직 한 부분만 수정하면 되기 때문에 변화를 잘 견뎌 낸다.

객체는 행동과 함께 데이터를 가진다. 데이터는 객체의 인스턴스 변수 속에 있으며 직접 참조하거나 액세서 메서드를 통해 접근할 수 있다.

- 인스턴스 변수 숨기기: 인스턴스의 변수를 직접 참조하는 것보다 액세서 메서드를 통해 변수에 접근하는 것이 좋다. 항상 데이터를 감추는 것이 좋으며 변수를 데이터처럼 생각해더라도 변수는 메시지를 통해 접근하는 것이 좋다.
- 데이터 구조 숨기기: 복잡한 데이터 구조에 의존하는 방식은 좋지 않다. 복잡한 구조를 직접 참조하면 진짜 데이터가 무엇인지 드러나지 않는다.

### 모든 곳에서 단일 책임 원칙을 강제하라

클래스뿐만 아니라 코드의 다른 부분에서도 단일 책임 원칙을 유용하게 적용할 수 있다.

`Gear` 클래스의 `gearInches()` 메서드를 예로 들어보자.

```js
...
	gearInches() {
    return this.ratio() * (this.rim + this.tire * 2);
  }
...
```

`gearInches`는 기어 인치를 구하는 하나의 책임만을 가지지만 기어 인치를 구하는 계산 과정 속에 바퀴의 지름을 구하는 계산을 포함하고 있기 때문에 하나 이상의 책임을 지는 것처럼 보인다. 이 부분을 메서드로 추출하면 클래스의 책임을 더 쉽게 파악할 수 있다.

```js
...
	diameter() {
		return rim + tire * 2;
	}

	gearInches() {
		return this.ratio() * this.diameter();
  }
...
```

메서드가 각각 하나의 책임을 가지면 메서드의 특성을 알기 쉽고, 주석이 불필요하며, 재사용을 유도하고, 다른 클래스로 옮기기 쉽다는 장점이 있다.

또한 클래스들의 추가적인 책임은 다른 클래스로 분리해서 작성해야한다. 많은 책임을 지고 있는 클래스가 있다면 핵심 클래스에 집중해야하며 다른 책임들은 격리시키고 핵심 클래스속에 스며들지 않게 해야한다.
