# 단일 책임 원칙을 따르는 클래스 디자인하기

- 객체지향 시스템의 근간을 이루는 것은 메세지(`message`)지만 가장 눈에 띄는 구조는 클래스.
- **클래스는 단순해야함.**
  - 지금 당장 해야할 일을 할 줄 암.
  - 나중에도 쉽게 수정할 수 있음.

---

## 무엇을 클래스에 넣을지 결정하기

- ### 메서드들을 묶어 클래스로 만들기
  - 주어진 상상의 범위 밖에서는 사고하기 힘든 하나의 박스를 만드는 것.
  - 프로젝트 초기 단계에서 메서드를 제대로 묶어내기 어려움.
  - 코드의 수정 가능성을 보존하는 기술(디자인) 적용.
- ### 수정하기 쉽도록 코드를 구성하기
  - #### 수정하기 쉽다의 정의
    - 수정이 예상치 못한 부작용을 낳지 않음.
    - 요구사항이 조금 변했을 때 연관된 코드들만 조금 수정하면 됨.
    - 현재 코드를 다시 사용하기 쉬움.
    - 코드를 수정하는 가장 쉬운 방법은 이미 수정하기 쉬운 코드에 새로운 코드를 추가하는 것.
  - #### 우리가 작성해야할 코드의 특징(`TRUE` 코드)
    - 투명하다(`Transparent`): 수정된 코드, 연관된 코드 속에서 수정의 결과가 뚜렷하게 드러나야 함.
    - 적절하다(`Reasonable`): 모든 수정 비용은 수정 결과를 통해 얻은 이득에 비례해야 함.
    - 사용가능하다(`Usable`): 예상치 못한 새로운 상황에서도 현재 코드를 사용할 수 있어야 함.
    - 모범이 된다(`Exemplary`): 코드 자체가 나중에 수정하는 사람이 위의 특징을 이어갈 수 있게 도와줘야 함.

---

## 하나의 책임만을 지는 클래스 만들기

> 클래스는 최대한 작으면서도 유용한 것(`smallest possible useful thing`). 하나의 책임만 있어야 함.

### 단일 책임 원칙은 왜 중요한가

- 쉽게 수정할 수 있는 애플리케이션은 재사용하기 쉬운 클래스(쉽게 가져다 쓸 수 있는 코드)로 구성.
- 한 개 이상의 책임이 있는 클래스는 재사용이 어려움.
  - 클래스 속에서 여러 책임들은 서로 얽혀 있을(결합, `coupled`) 가능성이 높음.
  - 특정 행동만 사용하고 싶어도 원하는 부분만 가져오기 어려움.
    > 이 경우 복사해서 사용 => 중복 코드 발생으로 유지보수 어려움 및 버그 유발.  
    > 클래스 전체를 가져다 씀 => 하나의 문제를 다른 문제로 가리는 것에 불과.
  - 재사용할 생각이 없어도 수정해야하는 경우 발생.

### 클래스에 하나의 책임만 있는지 알아보기

1. 클래스가 구현하고 있는 모든 메서드를 하나씩 질문 형태로 바꾸어 봄.
   - 다른 객체들의 관점에서 보면 그저 메세지에 반응하는 것.
   - 해당 클래스의 코드가 변경되었을 때 메세지를 보내던 객체는 당혹스런 상태에 빠짐. => 버그
2. 클래스의 책임을 한 문장으로 만들어 보는 것.
   - '그리고'와 같은 단어를 사용한다면 하나 이상의 책임을 가지고 있을 가능성.
   - '또는'과 같은 단어를 사용한다면 서로 연관되지도 않은 둘 이상의 책임을 가지고 있음.

> 응집력(`cohesion`), 클래스 안의 모든 것들이 하나의 핵심 목표와 연관되어 있을 때 이 클래스는 "강하게 응집되어 있다.(`highly cohesive`)", "하나의 책임만을 갖는다."고 할 수 있음.

#### 단일 책임 원칙

단일 책임 원칙(`SRP`)은 책임 주도 디자인(`RDD`)에 기원을 두고 있음.

> 클래스가 매우 협소한 한 가지 역할을 해야한다는 것, 사소한 수정만 해야 한다는 것이 아닌, **클래스가 응집되어 있어야 한다**는 의미.  
> 다시 말해서, 그 클래스의 모든 활동은 그 존재 이유와 밀접히 연관되어 있어야 함.

### 언제 디자인을 결정할지 판단하기

- 현재 클래스의 디자인이 훌륭하지 않더라도, 미래를 예측할 수 없기에 더 많은 정보를 얻을 때까지 기다리는 것이 가장 비용-효율적인 접근.
- **다른 객체와 의존성이 생긴**다면 투명함과 적절함을 잃게 되고, 바로 그 순간이 **코드 재구성을 재구성**해야 할 때.
- 새로운 의존성이 좋은 디자인을 결정하기 위한 정보를 제공.
- 현재 클래스의 구조는 미래의 개발자에게 지금의 디자인 의도를 전달하는 메세지.

---

## 변화를 받아들일 수 있는 코드 작성하기

- ### 데이터(`data`)가 아니라 행동(`behavior`)에 기반한 코드를 작성하라.

  - 행동은 메서드 속에 담겨 있고, 메세지를 보내는 행위를 통해 실행.
  - 하나의 책임만 지는 클래스를 만들면, 각각 작은 행동들은 단 한 곳에만 존재.
    - 이는 `Don't Repeat Yourself(DRY)` 원칙을 잘 따를 수 있는 예시임.
    - `DRY`한 코드는 클래스의 행동을 단 한 부분만 수정하면 되기 때문에 변화를 잘 견뎌냄.

  #### 1. 인스턴스 변수 숨기기

  객체는 행동과 데이터를 가짐.  
  이를 접근하기 위한 두 가지 방법.

  - 인스턴스 변수 직접 참조
  - 인스턴스 변수를 감사는 엑세서 메서드(`accessor method`)

  변수를 열 군데에서 참조하고 있고, 그 내용을 바꿔야 한다면 여러번 수정해야함.  
  하지만, 엑세서 메서드를 참조하면 어떤 의미인지 다시 정의하기 쉬움.

  - 간단한 경우

  ```ruby
  def cog
    @cog * unanticipated_adjustment_factor
  end
  ```

  - 조금 복잡한 경우

  ```ruby
  def cog
    @cog * (foo ? bar_adjustment : baz_adjustment)
  end
  ```

  데이터를 "메세지를 이해하는 객체" 처럼 취급하는 것 => 두 가지 새로운 이슈 생성.

  1.  가시성(`visibility`): 처음부터 `private`한 메서드를 만드는가, `public`한 메서드를 만드는가.
  2.  데이터와 객체 사이의 구분의 무의미 => 추상적

  > 변수를 직접 참조하기보다는 언제나 엑세서 메서드를 통해 접근하는 것이 좋음.  
  > 이를 통해 변수는 메세지 전송의 결과가 됨.  
  > 이는 여러 곳에서 참조하는 데이터(`data`)에서 단 한 번만 정의된 행동(`behavior`)로 바뀜을 의미.
  > 개발자 자신으로부터도 데이터를 감춰야 코드를 보호할 수 있음. => 개발자도 변수에 메세지로 접근.

  #### 2. 데이터 구조 숨기기

  - 복잡한 구조의 예시

  ```ruby
  class ObscuringReferences
    attr_reader :data
    def initialize(data)
      @data = data
    end

    def diameters
      # 0번 인덱스는 바퀴테(rim), 1번 인덱스는 높이(tire)
      data.collect {|cell|
        cell[0] + (cell[1] * 2)}
    end
    # ... 배열의 인덱스에 접근하는 여러 메서드들...
  end
  # 바퀴테와 타이어 높이 2차원 배열
  @data = [[622, 20], [622, 23], [559, 30], [559, 40]]
  ```

  위의 예시에서, `diameters` 메서드는 지름을 계산하는 방법과 배열의 데이터 구조를 모두 알고있음.  
  이는 배열의 구조에 의존적으로, 구조가 바뀐다면 코드도 변경되어야 함.  
  바퀴테 지름을 `[0]`에서 찾을 수 있다는 지식은 중복되어서는 안됨.

  - 복잡한 구조의 의존성을 제거한 예시

  ```ruby
  class RevealingReferences
    attr_reader :wheels
    def initialize(data)
      @wheels = wheelify(data)
    end

    def diameters
      # 배열의 구조에 대한 지식이 전혀 없음.
      # wheel.rim, wheel.tire라는 메세지 전송으로 바뀜.
      wheels.collect {|wheel|
        wheel.rim + (wheel.tire * 2)}
    end
    # ... now everyone can send rim/tire to wheel

    Wheel = Struct.new(:rim, :tire)
    def wheelify(data)
      # 배열의 지식을 격리.
      data.collect {|cell|
        Wheel.new(cell[0], cell[1])}
    end
  end
  ```

  > 복잡한 데이터 구조에 의존하는 방식은 좋지 않음.  
  > 외부에서 그런 복잡한 데이터 구조를 상세히 알 수 있다면, 그 데이터 구조에 의존적.  
  > "데이터 구조를 들여다보던 작업" -> "객체에 대한 메세지 전송"

- ### 모든 곳에 단일 책임 원칙을 강제하라.

  단일 책임 원칙은 클래스 뿐만 아니라, 코드의 다른 부분에도 유용하게 적용할 수 있음.

  #### 1. 메서드에서 추가적인 책임을 뽑아내기

  메서드 역시 하나의 책임만을 져야 함.

  - 한 메서드가 배열을 훑고, 바퀴의 지름을 계산하는 두 개의 책임 예시

  ```ruby
    def diameters
      wheels.collect {|wheel|
        wheel.rim + (wheel.tire * 2)}
    end
  ```

  - 배열을 훑는 메서드, 바퀴의 지름을 계산하는 메서드로의 분리.

  ```ruby
    def diameters
      wheels.collect {|wheel| diameter(wheel)}
    end

    def diameter(wheel)
      wheel.rim + (wheel.tire * 2)
    end
  ```

  만약 단 한 개의 바퀴의 지름을 계산하는 적용할 수 있다며느 이러한 리팩터링은 과도한 디자인이 아님.  
  이미 사용하고 있는 코드를 재구성했을 뿐.

  개별 객체에 행해지는 액션과, 객체들을 훑는 활동(`iteration`)을 분리하는 것은 쉽게 발견할 수 있는 **중복 책임**의 예시.

  - **리팩터링**  
    리팩터링은 디자인이 명확해서 필요한 것이 아님. 오히려 불명확하기 때문에 필요한 것.  
    하나의 리팩터링의 영향은 제한적이지만, 누적되면 영향은 매우 큼.

  > #### **하나의 책임을 지는 메서드가 가져오는 이점**
  >
  > 1. 예전에는 몰랐던 특성이 드러남.
  > 2. 주석을 넣어야 할 필요가 없어짐.  
  >    메서드 속에 있는 코드 한 조각에 주석을 달아야 한다면 그 코드를 별도의 메서드로 뽑아야 함.  
  >    뽑아낸 이름이 주석과 동일한 역할.
  > 3. 재사용을 유도함.
  > 4. 다른 클래스로 옮기기 쉬움.

  #### 2. 클래스의 추가적인 책임들을 격리시켜 놓아라

  모든 메서드들이 하나의 책임만 지게 되면 클래스의 역할 범위(`scope`) 역시 분명해짐.  
  수정하기 쉬운 코드를 작성하려면, 진짜 어쩔 수 없는 순간이 올 떄까지 최대한 디자인 결정을 미루는 것이 좋음.

  > 너무 많은 책임을 지고 있는 혼란스런 클래스가 있다면, 이 클래스의 책임을 다른 곳으로 분리.  
  > **핵심 클래스에 집중.** 아직 제거하기 어려운 추가적인 책임을 발견했다면, 그 책임을 격리시키고 관련 없는 책임들이 핵심 클래스 속에 스며들지 않도록 해야 함.

---

## 드디어, 진짜 바퀴

새로운 기능 추가 요청은 다음 디자인 결정을 내리는 데 필요한 정보를 제공.

- 자전거 바퀴 둘레를 계산하는 기능 요청이 들어왔을 때의 리팩터링

```ruby
  class Gear
    attr_reader :chainring, :cog, :wheel
    def initialize(chainring, cog, wheel = null)
      @chainring = chainring
      @cog = cog
      @wheel = wheel
    end

    def ratio
      chaingring / cog.to_f
    end

    def gear_inches
      ratio * wheel.diameter
    end
  end

  # 기존에 Gear 클래스에서 행동을 조심스럽게 구분해 놓았기 때문에
  # 손쉽게 Wheel Struct를 Wheel 클래스로 변경 가능.
  class Wheel
    attr_reader :rim, :tire

    def initialize(rim, tire)
      @rim = rim
      @tire = tire
    end

    def diameter
      rim + (tire * 2)
    end

    # 새로운 요청으로 추가된 메서드
    def circumference
      diameter * Math:PI
    end
  end
```

> `Gear`와 `Wheel` 모두 하나의 책임만 지게 됨.

---

## 요약

- 단일 책임 원칙은 수정하기 쉽고 유지보수하기 쉬운 객체지향 소프트웨어를 만드는 길.
- 한 가지만 하는 클래스, 그 행동을 애플리케이션의 다른 부분들로부터 분리(`isolation`)시키는 것이 예상치 못한 결과로부터 자유로운 수정을 할 수 있도록, 중복 코드 없이(`DRY`) 재사용 할 수 있도록 함.
